[ { "title": "CMU445 Project 1", "url": "/posts/CMU445_proj1/", "categories": "基础, 数据库", "tags": "数据库, MySQL", "date": "2024-10-14 19:25:00 +0800", "snippet": "CMU445该项目为 面向磁盘存储的DBMS，为现代数据库，本次主要围绕CMU5445中Project1讨论，分别实现 LRUKReplacer, DiskScheduler 以及 BufferPool 展开。BufferPool 实现LRU-k 算法LRU 算法用于管理Page缓存管理的驱逐策略，当缓存池中可存储的Page缓存不足时，便根据缓存中所有的Page在 bufferpool 中访...", "content": "CMU445该项目为 面向磁盘存储的DBMS，为现代数据库，本次主要围绕CMU5445中Project1讨论，分别实现 LRUKReplacer, DiskScheduler 以及 BufferPool 展开。BufferPool 实现LRU-k 算法LRU 算法用于管理Page缓存管理的驱逐策略，当缓存池中可存储的Page缓存不足时，便根据缓存中所有的Page在 bufferpool 中访问的记录决定驱逐的 Page，LRU算法会驱逐访问记录最早的Page, 也即在缓存池中访问的时间戳最小，是对局部性访问原理的一种应用。LRU-k 算法相比 LRU 算法，额外记录每个 Page k 次历史访问时间戳，k表示每项Page访存记录的最大大小，可解决有些 Page 访问的次数少而最近访问，与Page访问次数多但较早访问的情况，在实际驱逐过程中错误的将这种冷数据保留，热数据却被驱逐。根据1中的实验结果可知，实际情况将 k 设置为 2 的效率较高。LRU-k 算法本质上通过将访问记录按照访问频率分为冷数据和热数据，两中数据记录采用不同的驱逐策略：其中冷数据部分采用 FIFO 策略驱逐，而热数据则采用 LRU-k 策略驱逐。LRU-k 算法： 有访存记录，则在LRU模块中记录对应的Page号以及时间戳，每项记录的时间戳最多保存 k 项 若需要驱逐对应的 frame ： 页面访存次数少于 k 次的优先考虑驱逐 访存次数至少 k 次的则按照最近访问和上一个第k次访问的时间戳差值为 k-distance, 并将 k-distance 最大的优先驱逐 多个访存次数少于 k 次的按照LRU算法，优先驱逐最早访存的Page 设计思路接口：// 根据上述策略选择需要驱逐的 frameEvict() -&gt; std::optional&lt;frame_id_t&gt;;// 记录该 frame 访问时间戳RecordAccess(frame_id_t frame_id);// 不通过驱逐，而是直接移除对应的 frameRemove(frame_id_t frame_id);// 该方法的目的在于保证对应的 frame 不在驱逐列表中(有线程持有对应 `page` 的资源)SetEvictable(frame_id_t frame_id, bool set_evictable);// 给出当前 replacer 中可以驱逐的 frame 数量(不是 replacer 的容量)Size() -&gt; size_t : This method returns the number of evictable frames that are currently in the LRUKReplacer.根据实际操作有两种管理资源的策略： 懒维护：所有的访问修改操作都不会对内部做额外的操作，仅在驱逐的时候才进行统计，并给出对应的 frame_id； 实时维护：所有的访问修改操作都会动态修改内部结构，保证驱逐时最高效得出驱逐的 frame_id; 策略 优点 缺点 懒维护 访问修改操作复杂度低，为O(1); 不需要额外的空间存储并维护 Evict(): T = O(nlogn) 实时维护 Evict(): T = O(1) 访问修改操作复杂度为 O(n)，使用堆则为O(logn); 需要维护 history_queue_ 和 cached_queue_ 对应需要管理的资源：std::unordered_map&lt;frame_id_t, LRUKNode&gt; node_store_; // 存放所有 frame 的容器std::list&lt;frame_id_t&gt; history_queue_; // 不满足 k 次访问可驱逐，并按照 FIFO 顺序存放的 framestd::list&lt;frame_id_t&gt; cached_queue_; // 满足 k 次访问可驱逐，按照 LRU-k 的 K-distance 存放的 frame// 辅助变量// {std::atomic&lt;size_t&gt; current_timestamp_{1};size_t curr_size_{0};size_t replacer_size_;size_t k_;std::mutex latch_;// }可以看到上述所有的操作都会涉及到修改对应的容器，所以都需要加锁，但不需要细粒度锁。实现根据CMU445的Policy不能共享对应的代码实现，所以这里只提供对应的思路。 懒维护仅在 Evict() 时才开始确认驱逐的 frame_id: auto evict() -&gt; std::optional&lt;page_id_t&gt; { std::scoped_lock guard(latch_); if(cur_size_) return std::nullopt std::vector&lt;LRUKNode *&gt; arr; for(auto &amp;[page_id, entry] : node_store_){ if(!entry.Evictable()) continue; arr.emplace_back(&amp;entry); } // 这里比较的策略就是上述的，不足k次访问的 frame 按照FIFO优先驱逐；满足k次的则按照 lru-k 的 k-distance 计算驱逐优先级 std::ranges::sort(arr, [](const LRUKNode *l, const LRUKNode *r){ return *l &lt; *r; }); --cur_size_; auto entry_ptr = arr.front(); entry_ptr.reset(); return entry_ptr.fid_;} 实时维护RecordAccess(), Remove(), SetEvictable() 都会改变可能修改优先驱逐列表(history_queue, cached_queue), 所以在这些操作中都需要将对应的frame重新排序磁盘调度器 DiskScheduler磁盘调度器作用为调度读写磁盘操作，内部有缓冲队列，后台线程按序利用磁盘管理器执行缓冲队列中的磁盘读写请求。这里的磁盘读写请求包括了提供给磁盘管理器的执行所需的所有信息：页号和数据 buffer 地址。是根据 buffer_pool 调用磁盘调度器接口的驱动方式执行的调度器。实现/** * @brief Represents a Write or Read request for the DiskManager to execute. */struct DiskRequest { /** Flag indicating whether the request is a write or a read. */ bool is_write_; /** * Pointer to the start of the memory location where a page is either: * 1. being read into from disk (on a read). * 2. being written out to disk (on a write). */ char *data_; /** ID of the page being read from / written to disk. */ page_id_t page_id_; /** Callback used to signal to the request issuer when the request has been completed. */ std::promise&lt;bool&gt; callback_;};void DiskScheduler::Schedule(DiskRequest r) { request_queue_.Put(std::move(r)); }void DiskScheduler::StartWorkerThread() { while (auto request = request_queue_.Get()) { if (request-&gt;is_write_) disk_manager_-&gt;WritePage(request-&gt;page_id_, request-&gt;data_); else disk_manager_-&gt;ReadPage(request-&gt;page_id_, request-&gt;data_); request-&gt;callback_.set_value(true); }}缓冲池管理器 BufferPoolManager我们用 FrameHeader 作为主存中的一个 frame 元数据 其中 Frame 为对应物理存储的 Page 的逻辑表示。BufferPool 内部有多个 Frame 用于存储磁盘中的 Page, 该类需要根据外部的请求维护内部 Frame 是否继续保存对应的 Page 以及换出 Page 的时机2。接口：// BufferPool关键对外接口auto NewPage() -&gt; page_id_t;auto DeletePage(page_id_t page_id) -&gt; bool;auto WritePage(page_id_t page_id) -&gt; WritePageGuard;auto ReadPage(page_id_t page_id) -&gt; ReadPageGuard;auto FlushPage(page_id_t page_id) -&gt; bool;维护的资源：std::vector&lt;std::shared_ptr&lt;FrameHeader&gt;&gt; frames_;std::unordered_map&lt;page_id_t, frame_id_t&gt; page_table_;std::list&lt;frame_id_t&gt; free_frames_;// 用于保护上述关键资源以及下面可能会被多进程调用的资源(next_page_id_, replacer_, disk_scheduler_)// 实际设计的时候可以为降低锁粒度，将bpm_latch_分为: // page_table_latch_, free_frames_latch_, 其他的多线程同步变量则用 atomic 装饰// replacer_ 有自行维护的互斥量，不需要额外进行维护std::shared_ptr&lt;std::mutex&gt; bpm_latch_;// 辅助变量std::shared_ptr&lt;LRUKReplacer&gt; replacer_;std::shared_ptr&lt;DiskScheduler&gt; disk_scheduler_;const size_t num_frames_;std::atomic&lt;page_id_t&gt; next_page_id_;实现 NewPage()涉及同步的变量仅有 next_page_id_, 且对访问顺序无要求，所以无序加锁，且 fetch_add() 仅需 std::memory_order_relaxed. DeletePage()涉及多个锁的持有，需要按照给定的顺序进行加锁，如果出现错误顺序，需要提前解锁低优先级的锁 Write/ReadPage()涉及多个锁的持有，需要按照给定的顺序进行加锁，如果出现错误顺序，需要提前解锁低优先级的锁 FlushPage()该过程涉及查找 page 以及对对应 page 的 frame 存储内容落盘，那么加锁顺序应为 page_table_latch_ 以及 frame 对应的 rw_latch_.参考 LRU-k paper &#8617;&#xfe0e; [MySQL · 源码分析 · 庖丁解 InnoDB 之 Buffer Pool] http://mysql.taobao.org/monthly/2023/08/01/ &#8617;&#xfe0e; " }, { "title": "从异步回调到C++20中的协程", "url": "/posts/coroutine/", "categories": "C++, 协程", "tags": "C++, 协程", "date": "2024-09-29 15:43:00 +0800", "snippet": "协程解释协程 coroutine 前需要了解例程 routine, 即一系列连续的操作, 例程执行可构成调用关系，被调用例程总是在调用例程之前返回，且在单一执行流(单线程环境下)中例程不可由用户主动暂停。当然实际情况下函数与例程的表现是等价的，后面我们都以例程表示。协程则是例程的推广形式，可以通过保留执行状态(现在我们都称其为协程栈)实现手动暂停和恢复进度，提供更强的灵活性。与线程相比，使用...", "content": "协程解释协程 coroutine 前需要了解例程 routine, 即一系列连续的操作, 例程执行可构成调用关系，被调用例程总是在调用例程之前返回，且在单一执行流(单线程环境下)中例程不可由用户主动暂停。当然实际情况下函数与例程的表现是等价的，后面我们都以例程表示。协程则是例程的推广形式，可以通过保留执行状态(现在我们都称其为协程栈)实现手动暂停和恢复进度，提供更强的灵活性。与线程相比，使用协程在io密集型任务重可有效降低资源调度成本，并减少内核态-用户态切换的开销。协程特性 连续多次调用协程，仍然保持局部变量值 可暂停可恢复 支持对称和非对称的控制流切换 是一种 一等对象1 first-class object, 也即可被当做一般的对象使用，同时无其他任何限制，在C++中 lambda表达式返回的对象 和 重载()操作符的对象可被认为是一种一等对象. 有栈(支持嵌套调用)或无栈(不支持，或者需要保存调用协程来实现嵌套调用)应用-事件驱动模型事件驱动模型 是一种编程范式，其程序流受事件影响，事件则来自多个无关事件源，在该模型中有一个事件分配器，等待外部的源在将来的任何时候触发回调函数，整个模型则可分为 事件选择 和 事件处理. 可以看到这样的结构组件之间是松耦合的，该模型的使用场景则包括: UI应用(用户点击和组件槽发送信号)、WebServer(外部用户通过网络请求本地文件)、游戏画面渲染(帧事件驱动)为什么要使用这样的模型，不能使用线程实现吗？ 多线程需要考虑更多的多线程安全问题 内存需求高 创建维护线程状态昂贵 线程上线文切换成本高相对的使用协程则可以： 单一控制流，不需要考虑多线程安全问题 上下文切换不需要切换到内核态异步实现更早的时期，为了实现事件循环的异步操作，需要引入回调函数，并将执行控制流分为多个部分，按照整个控制流中所有可能引起例程挂起的 关键点 进行切割，举例：/* psuedo code This is a webserver, as a server end program, we should listen all clients' requests, plus waiting for any un completed i/o. */int sockfd = create_bind_listen_socket();// hung up / blocked if no one request for anything from hereint connfd = accept(sockfd)// generate a thread to process this connfd as below described: void thread_handle(int connfd): // repeat do read/write stuff until connection state timeout, // reset/closed by peer or closed by self while(!stop_token): // blocked if no content yet ssize_t recvsz = read(connfd) // blocked if send buffer full already ssize_t sendsz = write(connfd);对于线程来说，执行上述的例程中的函数，一旦阻塞，则会被迫挂起，同时被操作系统调度，该过程上下文切换成本非常高，使用 回调函数 则把这样的执行例程拆分为多个部分：/* wrapper for this routine, and read/write could be paused/reenterd, cuz we save all local variables in io_context +-------+ +--------+ +---------+ | | | | | | | start +----+---&gt;| read +-------&gt;| write +--------+ | | | | | | | | +-------+ | +--------+ +---------+ | | | +------------------&lt;---------------------+ */struct session : std::enable_shared_from_this /* shared this session to callback pool but no need to leak address of io_context */ { // io_context means all fd resources here are non-block type session(io_context ctx) : socket_(ctx) {} operator socket() { return socket_; } void start() { do_read(); } void do_read() { // async read operation ssize_t res = nonblock_read(); // check if read failed with the EAGAIN error, // which means we should check later if this operation is done // We can achieve this by epoll if(res){ // only focus on normal EAGAIN situation, like this register_do_read_operation_later(); } else do_write(); } void do_write() { // async write operation ssize_t res = nonblock_write(); // check if write failed with the EAGAIN error, // which means we should check later if this operation is done // We can achieve this by epoll if(res){ // only focus on normal EAGAIN situation, like this register_do_write_operation_later(); } this-&gt;do_read(); } socket socket_; static size_t max_length = 1024; char data_[max_length];}可以看到，使用回调函数的方式实现异步，会导致原始例程需要被拆分为多个小的回调函数，并且这个过程中会引入新的作用域和错误回调问题，大幅降低代码可读性和编码稳定性，更重要的，会提高我们的心智成本。在 boost 中则有提供类似于协程的异步实现，使得实际编码风格可以接近例程。void session(boost::asio::io_service&amp; io_service){ // construct TCP-socket from io_service boost::asio::ip::tcp::socket socket(io_service); try{ for(;;){ // local data-buffer char data[max_length]; boost::system::error_code ec; // read asynchronous data from socket // execution context will be suspended until // some bytes are read from socket std::size_t length=socket.async_read_some( boost::asio::buffer(data), boost::asio::yield[ec]); if (ec==boost::asio::error::eof) break; //connection closed cleanly by peer else if(ec) throw boost::system::system_error(ec); //some other error // write some bytes asynchronously boost::asio::async_write( socket, boost::asio::buffer(data,length), boost::asio::yield[ec]); if (ec==boost::asio::error::eof) break; //connection closed cleanly by peer else if(ec) throw boost::system::system_error(ec); //some other error } } catch(std::exception const&amp; e){ std::cerr&lt;&lt;\"Exception: \"&lt;&lt;e.what()&lt;&lt;\"\\n\"; }}C++20中的协程在 C++20 新增三个关键字 co_yield, co_eturn, co_await, 当一个函数类似的代码块中有任意所述的关键字，那么就认为该代码块为协程，可在关键字处 暂停 并返回调用者的执行位置。但是，这些功能并未直接实现，C++20仅是暴露对应的接口和规范，我们仍然需要自行实现对应的接口或者使用第三方库实现。协程额外的概念一个协程总是带有: Awaiter(决定协程被挂起时的行为), Awaitable(可以提供Awaiter对象), Promise(定义协程在不同状态下的操作)，至于硬性实现，请参考cppref。协程支持std::coroutine_handleAwaiter对于 Awaiter 对象来说，其成员函数应用时机为： await_ready() 调用co_await 时用于判断子协程是否就绪 await_suspend() await_ready()判断未就绪即将子协程挂起，会调用 await_suspend() await_resume() co_await 返回结果时，会调用 await_resume()等价操作对于 co_await 来说，调用该方法等价于: co_await promise().yield_value()参考 一等对象 &#8617;&#xfe0e; " }, { "title": "HyperLogLog", "url": "/posts/HyperLogLog/", "categories": "算法", "tags": "算法, Redis", "date": "2024-09-24 15:19:00 +0800", "snippet": "介绍HLL, HyperLogLog 是一种基于概率统计的基数计算模型，例如可用于高效统计一个网站单日访问用户的数量，或用于统计每个单独的key出现次数(Redis中常用). 最简单的理解可认为是一种抛硬币问题，连续出现1的几率会逐渐降低，但随着抛硬币次数增加，最后会收敛于 $2^{-n}$, 借此可以估计 n 的大小，也就是抛硬币次数 ；同理，统计访客(键)对应的哈希值，随着访客次数增加，...", "content": "介绍HLL, HyperLogLog 是一种基于概率统计的基数计算模型，例如可用于高效统计一个网站单日访问用户的数量，或用于统计每个单独的key出现次数(Redis中常用). 最简单的理解可认为是一种抛硬币问题，连续出现1的几率会逐渐降低，但随着抛硬币次数增加，最后会收敛于 $2^{-n}$, 借此可以估计 n 的大小，也就是抛硬币次数 ；同理，统计访客(键)对应的哈希值，随着访客次数增加，哈希值低位连续出现1的频率也会服从于总不重复访客数量(n)对应的概率 $2^{-n}$.相比直接使用set存储对应的键，然后统计内部元素数量得到该集合的基，使用HLL可以最大程度降低存储开销，如HLL名称所示，其存储开销可认为是样本总体基为 N, 那么HLL的存储开销为 O(log(log(N)))常见的实现 统计哈希值最高位的1下标(从大到小，从1逐渐增大)，根据下标来判断当前估计的集合基数； 统计哈希值最低位连续0的个数；两种方式统计随添加的元素数量增加，趋于等价的结果。优化概率模型极小事件导致误差虽然说HLL用小空间可以相对较为精准的估计出大量数据下的集合基数，但在小数据规模则容易出现较大的误差。解决方法统计的哈希值放入多个bucket中，并计算每个bucket的调和平均数，这样可以降低因为小概率事件导致误差较大的问题。具体实现哈希值分为两部分，其中一部分用于确认放入哪个bucket，另外一部分用于统计连续0的个数。小概率事件减少存储前面说到统计哈希值低位连续0的个数或最高位1的下标，但连续多个数字的事件是小概率事件，实际上存储的bucket可以分为存储低位的连续存储(DenseBucket)，和存储高位的哈希表存储(OverflowBucket)，可以大幅降低设置多个bucket导致存储开销明显增加。这里可以固定两种 bucket 存储的位数，例如统计出的连续数字个数为 33, 当前存储低位部分的bucket只负责低4位，而存储高位的部分只负责高3位，并通过哈希值确认存放的bucket 下标为 3,那么 DenseBucket[3] = 1, OverflowBucket[3] = 2.高位存储采用哈希表的稀疏存储方式，不会因为设置过多的DenseBucket存储位数的影响而占用过多存储。变种HyperLogLog++, 相比HLL区别在： 计算的hash值从32位增加到64位，可提高统计基数的最大上限 计算公式中添加的偏差修正系数 稀疏的存储方式进一步降低存储(就是上面所说的优化)参考 HyperLogLog Video 维基百科" }, { "title": "网络TCP总结", "url": "/posts/%E7%BD%91%E7%BB%9CTCP%E6%80%BB%E7%BB%93/", "categories": "基础, 网络", "tags": "基础", "date": "2024-09-18 16:33:00 +0800", "snippet": "Linux 中的 TUN/TAP 设备在学习CS144过程中，作者实验指导中讲述到，内核实现运输层和网络层的数据包封装，如果我们自己也想自行进行封装，则需要采用 TUN/TAP 设备文件，实现自行封装，并提供封装结果。这里 TUN 设备作用则是作为网络层的 IP 类似的协议实现对运输层及更高层的数据进行封装；而 TAP 设备则提供数据链路层中的协议实现，可对网络层及更上层的数据进行封装。其中...", "content": "Linux 中的 TUN/TAP 设备在学习CS144过程中，作者实验指导中讲述到，内核实现运输层和网络层的数据包封装，如果我们自己也想自行进行封装，则需要采用 TUN/TAP 设备文件，实现自行封装，并提供封装结果。这里 TUN 设备作用则是作为网络层的 IP 类似的协议实现对运输层及更高层的数据进行封装；而 TAP 设备则提供数据链路层中的协议实现，可对网络层及更上层的数据进行封装。其中 TUN/TAP 设备文件都存放在 /dev/net/ 下。创建 TUN/TAP 设备可以参考: Linux Kernel tuntap refTCP 相关TCP 是一种基于IP栈上实现的一种双工有连接的可靠字节流传输协议，通过有效的职责划分，可将 TCP 栈分为多层结构：字节流，重组器，发送器，接收器，连接器，相对关系如下：这些组件共同构成一个 tcp 实体，每个组件分别实现功能，仅为简化的实现，完成 TCP 必要功能的实现： 字节流(bytestream): 流式内容的基本容器，记录流中 pushed 和 popped 的字节数量，也可手动关闭字节流； 流重组器(reassembler): 接收端字节流的 wrapper ，由于 ip stack 的特性，即数据包在网络中的传输是乱序的，所以接收端采用重组器缓存接收窗口范围内的字节，并在合适的情况下组装字节流，发送到 bytestream 中； 接收器(receiver): 负责接收 peer 发送来的 tcp segment (序列长度不能为0)，根据接收到的 segment ，判断当前的 fsm 状态，包括：listen, syn_recv, fin_recv, closed, error, 同时返回当前可以接受的接收窗口，并保证接受到的字节流可以有序的接收(流重组器重新组装字节流)； 发送器(sender): 负责主动向对端发起建立连接，根绝对端的接收窗口更新自身的发送窗口(推断对端接收能力)，发送字节流，同时保证发送的字节流可以可靠地发送出去(超时重传,推断网络拥塞情况), 连接器(connection): 负责可选择地维持 TCP 连接( Keepalive 操作); 根据接受的 tcp segment判断是 ack segment还是 sequence segment, 并将 segment 送入 sender 兼或 receiver (捎带机制，除了 syn seg, 发送的 seq 会携带自身 receiver 的接收窗口状态，也即 SEQ+ACK seg); 根据对端和自身的 sender 和 receiver 互相发送接收的 segment 来判断当前 tcp 连接的状态，并给出对应的行为(大部分 sender 和 receiver 已经实现，Connection 需要实现关闭连接的 closed_wait 操作, 管理 sender 发送的 segment 重传次数过多则转为 error);这里给出具体的 TCP segment传入传出的流图：后面针对上述的各个组件分别进行解释。字节流(ByteStream)为了实现一个可为上级提供可靠的字节流服务，该字节流内部需要有缓冲区：可以缓存部分字节流的内容，当上层(应用层软件)从字节流中读取部分字节后，字节流将该部分弹出；从下层(外部对端segment)接受的字节有序的放入字节流缓冲区中。我们可以看出这里需要确定能够缓冲的最大容量(capacity);预料外的情况：需要主动放弃继续更新字节流，同时能够提供接口告知外部自身已经出现异常;流结束：提供接口告知外部当前字节流已经达到结尾(eof, end of file).其中可靠性可以参考RFC793的描述：The TCP must recover from data that is damaged, lost, duplicated, or delivered out of order by the internet communication system.这里针对字节流的要求则为保证接收到的字节能够正确组装到末尾。这样的字节流接口为：class ByteStream{public: explicit ByteStream( uint64_t capacity ); void set_error() { error_ = true; } bool error() const { return error_; }protected: uint64_t capacity_ {}; // ByteStream可以同时容纳的容量 bool error_ {}; bool closed {}; // 字节流是否已经发送到末尾 uint64_t pushed_size_ {}; // 从对端发送并压入ByteStream的字节数 uint64_t popped_size_ {}; // 发送给客户端并弹出的ByteStream的字节数}同时根据该字节流给出 writer 和 reader 的子类实现：class Reader;class Writer;// ByteStream 在64位系统中 size: 64字节 8字节对齐class ByteStream{public: explicit ByteStream( uint64_t capacity ); // 辅助接口类，用于访问字节流 Reader&amp; reader(); const Reader&amp; reader() const; Writer&amp; writer(); const Writer&amp; writer() const; void set_error() { error_ = true; } bool error() const { return error_; }protected: uint64_t capacity_ {}; // ByteStream可以同时容纳的容量 bool error_ {}; bool closed_ {}; // 字节流是否已经发送到末尾 std::string buffer_ {}; // 底层实现可以有多种: string, deque, cycled_queue等等 uint64_t pushed_size_ {}; // 从对端发送并压入ByteStream的字节数 uint64_t popped_size_ {}; // 发送给客户端并弹出的ByteStream的字节数}// Helper Class 用于从字节流中读取相关的操作class Reader : public ByteStream{public: std::string_view peek() const; void pop(uint64_t len); bool is_finished() const; // Reader 判断是否结束：closed_ 且 bytes_buffered() == 0 uint64_t bytes_buffered() const; uint64_t bytes_popped() const; }// Helper Class 用于向字节流中写入字节相关操作class Writer : public ByteStream{public: void push(std::string data); void close(); bool is_closed() const; // Writer 仅需要判断是否 closed_ 为 true 即可 uint64_t bytes_pushed() const; bool available_capacity() const;}// Helper Class 实现ByteStream::ByteStream( uint64_t capacity ) : capacity_( capacity ) {}bool Writer::is_closed() const{ return closed_;}void Writer::push( string data ){ if(error_ || is_closed() || data.empty()) return; if(data.size() &gt; available_capacity()) data = data.substr(0, available_capacity()); buffer_.append(data); pushed_size_ += data.size();}void Writer::close(){ closed_ = true;}uint64_t Writer::available_capacity() const{ return capacity_ - buffer_.size();}uint64_t Writer::bytes_pushed() const{ return pushed_size_;}bool Reader::is_finished() const{ return closed_ &amp;&amp; buffer_.empty();}uint64_t Reader::bytes_popped() const{ return popped_size_;}string_view Reader::peek() const{ return buffer_;}void Reader::pop( uint64_t len ){ if(buffer_.empty()) return; len = std::min(len, buffer_.size()); buffer_.erase(0, len); popped_size_ += len;}uint64_t Reader::bytes_buffered() const{ return buffer_.size();}可以看到这里我们实现 ByteStream 使用的是 std::string, 而没有使用 deque 或者 cycled_queue 原因在于： 双端队列，优势在两边插入和弹出的复杂度都为 O(1), 但是 peek 时需要将底层的地址暴露给 string_view, 而双端队列并不是连续的存储，可能 peek 的内容中在双端队列的多个子 buffer 中，不能 O(1) 时间和空间复杂度下提供对应的 view ，需要额外使用其他的连续存储结构来存中间变量，才可保证访问 string_view 的过程中不会出现空悬引用，ByteStream的 peek 的时间复杂度就退化为 O(n) 空间复杂度也为 O(n)； 循环队列，同样的问题，需要处理不连续的情况，如果当前队列存储的内容是连续的状态，那么可以直接提供给 string_view 对应的地址和大小，但出现不连续的情况(一部分在队列尾端，一部分在队列头端)同样会使得循环队列 peek 的时间复杂度提高到 O(n), 同时需要额外的存储，空间复杂度为 O(n); string, 虽然 string 在 pop 的过程中使用到 substr 使时间复杂度变为 O(n), 但是在 peek 的过程中不会出现不连续存储的情况，保证提供 string_view 的时间复杂度和空间复杂度都为 O(1).那么如果 peek 调用次数较大，使用 string 的实现较为合适，插入弹出更为频繁，那么采用双端队列或循环队列的实现则更合适，我们这里采用 string 实现字节流应同时提供读写功能，且在两端中都出现，也即一端分别有发送字节流和接收字节流，实现对应的双工字节流管道。流重组器(Reassembler)流重组器，该组件为 Receiver 中保证接收的字节流能够按序重组，按照可靠性的要求，保证：The TCP must recover from data that is damaged, lost, duplicated, or delivered out of order by the internet communication system.中重复的部分会被合理丢弃，乱序字节可以正确重组为原始顺序。为了达到识别正确的顺序已经抛出重复字节，流中的每个字节需要有对应的流下标(stream_index)流重组器(StreamReassembler)定义：class Reassembler{public: explicit Reassembler(ByteStream &amp;&amp;output) : output_(std::move(output)) {} void insert( uint64_t first_index, std::string data, bool is_last_substring ); // 流重组器中等待插入到ByteStream的字节数 uint64_t bytes_pending() const; // Helper Class interfaces // Access output stream reader Reader&amp; reader() { return output_.reader(); } const Reader&amp; reader() const { return output_.reader(); } // Access output stream writer, but const-only (can't write from outside) const Writer&amp; writer() const { return output_.writer(); } void ser_error() { output_.set_error(); } bool has_error() const { return writer().has_error(); }private: // Helper Function interact with storage_ // insert unvalid data into storage_ void insert_into_storage(const uint64_t first_index, std::string &amp;&amp;data); // pop all valid data into output_ void pop_from_storage();private: uint64_t bytes_pending_ = 0; std::vector&lt;std::pair&lt;uint64_t, std::string&gt;&gt; storage_ = {}; bool has_last_ = {false}; uint64_t last_index = 0; ByteStream output_;}具体实现：// 合法性检查：ByteStream 是否有空间存储，data 是否有数据可存// 对合法的 data 中不在范围内(ByteStream可以压入的 [index, index+capacity) )// 将合法的部分放到自己的 storage 中// 如果当前存在storage中的 data 满足压入 ByteStream 的情况，则立刻将 data 压入 ByteStreamvoid Reassembler::insert( uint64_t first_index, string data, bool is_last_substring ){ if ( writer().available_capacity() == 0 ) { return; } if ( data.empty() ) { if ( is_last_substring ) { output_.writer().close(); } return; } if ( is_last_substring ) { has_last_ = true; last_index = first_index + data.size(); } // data's indices: [first_index, end_index) // Bytestream's need to pushed indices: [0, bytes_pushed) // which means first unpushed index is `bytes_pushed` // first unacceptable index is bytes_pushed + available_capacity uint64_t end_index = first_index + data.size(); uint64_t availible_first_index = writer().bytes_pushed(); uint64_t unavailible_first_index = writer().bytes_pushed() + writer().available_capacity(); // discard all data which totally beyond situations reassebler could handled. if ( end_index &lt;= availible_first_index || first_index &gt;= unavailible_first_index ) return; // discard last bytes of unavailible data if ( end_index &gt; unavailible_first_index ) { data = data.substr( 0, data.size() - end_index + unavailible_first_index ); end_index = unavailible_first_index; } // discard prev bytes of data which already pushed if ( first_index &lt; availible_first_index ) { data = data.substr( availible_first_index - first_index ); first_index = availible_first_index; } insert_into_storage( first_index, std::move( data ) ); if(availible_first_index == storage_.front().first){ pop_from_storage(); availible_first_index = writer().bytes_pushed(); } // check if all data pushed into bytestream if ( storage_.empty() &amp;&amp; has_last_ &amp;&amp; availible_first_index == last_index ) { output_.writer().close(); }}// 将当前压入的data和storage中的data进行比较，实现去重// 有重复的部分就剔除，无重复部分按照插入排序的思路将data插入到 storage_ 中void Reassembler::insert_into_storage( const uint64_t first_index, std::string&amp;&amp; data ){ auto begin_index = first_index; const auto end_index = begin_index + data.size(); // find position to insert data in order for ( auto it = storage_.begin(); it != storage_.end() &amp;&amp; begin_index &lt; end_index; ) { if ( begin_index &gt;= it-&gt;first ) { begin_index = std::max( begin_index, it-&gt;first + it-&gt;second.size() ); it++; continue; } if ( begin_index == first_index &amp;&amp; end_index &lt;= it-&gt;first ) { bytes_pending_ += ( end_index - begin_index ); storage_.emplace( it, begin_index, std::move( data ) ); return; } // begin_index &lt; it-&gt;first const auto right_index = std::min( end_index, it-&gt;first ); const auto len = right_index - begin_index; it = storage_.emplace( it, begin_index, data.substr( begin_index - first_index, len ) ); bytes_pending_ += len; begin_index = right_index; } // handle situation when storage is empty if ( begin_index &lt; end_index ) { bytes_pending_ += ( end_index - begin_index ); storage_.emplace_back( begin_index, data.substr( begin_index - first_index ) ); }}void Reassembler::pop_from_storage(){ for ( auto it = storage_.begin(); it != storage_.end(); ) { if ( it-&gt;first &gt; writer().bytes_pushed() ) break; output_.writer().push( it-&gt;second ); bytes_pending_ -= it-&gt;second.size(); it = storage_.erase( it ); }}uint64_t Reassembler::bytes_pending() const{ return bytes_pending_;}接收器(Receiver)虽然有重组器可以将接收到的字节流有序可靠地重组为原始序列，但当字节流要经过网络进行传播时，就需要额外的状态处理实现判断当前字节流是否合法。接收器则提供了三种合法状态以及一种异常状态。对应的相比字节流，多两个标识位下标：SYN以及FIN，这两个要额外占用序列号，参考下表：且从外部发送的序列号(Seq)为32bit大小，实际数据传输在100gb/s的情况下只需要秒级即会消耗完所有的序列号，所以实际上网络中传递的序列号为相对序列号，发送方和接收方内部的序列号为绝对序列号，然后通过转换得到32bit的序列号。class Wrap32{public: explicit Wrap32( uint32_t raw_value ) : raw_value_( raw_value ) {} static Wrap32 wrap( uint64_t n, Wrap32 zero_point ); uint64_t unwrap( Wrap32 zero_point, uint64_t checkpoint ) const; Wrap32 operator+( uint32_t n ) const { return Wrap32 { raw_value_ + n }; } bool operator==( const Wrap32&amp; other ) const { return raw_value_ == other.raw_value_; }protected: uint32_t raw_value_ {};};// uint64_t -&gt; Wrap32 时仅需要将高位裁掉即可，然后根据 isn 转为相对 seqWrap32 Wrap32::wrap( uint64_t n, Wrap32 zero_point ){ return Wrap32 { static_cast&lt;uint32_t&gt;( n ) + zero_point.raw_value_ };}// Wrap32 -&gt; uint64_t 根据 isn 和 next_seq或bytes_pushed 作为checkpoint 将相对 seq 转为 abs_sequint64_t Wrap32::unwrap( Wrap32 zero_point, uint64_t checkpoint ) const{ auto diff = raw_value_ - zero_point.raw_value_ - static_cast&lt;uint32_t&gt;( checkpoint ); uint64_t result; if(diff &lt;= (1u &lt;&lt; 31)){ result = checkpoint + diff; }else{ result = checkpoint - ((1ul &lt;&lt; 32) - diff); if(result &gt; checkpoint){ result = checkpoint + diff; } } return result;}TCPReceiver 中，需要考虑当前消息对应实际的流index在哪里，需要从 seq_no -&gt; abs_seq_no -&gt; stream_index 其中 stream_index 从实际的内容开始计算下标，而 abs_seq_no 则从 SYN segment 开始就开始统计，同时 FIN 也会占用 abs_seq_no, 所以当我们请求下一个 segment 时，需要根据当前是否建立连接， bytestream 是否已经 close 来计算从 stream_index -&gt; abs_seq_no 的映射class TCPReceiver{public: // Construct with given Reassembler explicit TCPReceiver( Reassembler&amp;&amp; reassembler ) : reassembler_( std::move( reassembler ) ) {} /* * The TCPReceiver receives TCPSenderMessages, inserting their payload into the Reassembler * at the correct stream index. */ void receive( TCPSenderMessage message ); // The TCPReceiver sends TCPReceiverMessages to the peer's TCPSender. TCPReceiverMessage send() const; // Access the output (only Reader is accessible non-const) const Reassembler&amp; reassembler() const { return reassembler_; } Reader&amp; reader() { return reassembler_.reader(); } const Reader&amp; reader() const { return reassembler_.reader(); } const Writer&amp; writer() const { return reassembler_.writer(); } void set_error() { reassembler_.ser_error(); } bool has_error() const { return reassembler_.has_error(); }private: std::optional&lt;Wrap32&gt; isn_ = std::nullopt; u_int64_t ackno_ = 0; Reassembler reassembler_;};void TCPReceiver::receive( TCPSenderMessage message ){ // check if RST segment incoming if ( message.RST ) { set_error(); } if ( has_error() ) return; // discard anything before the SYN segment if ( !isn_.has_value() ) { if ( !message.SYN ) return; isn_ = message.seqno; } // 1. calc abs_seqno from message, seqno -&gt; abs_seqno auto abs_seqno = message.seqno.unwrap( isn_.value(), writer().bytes_pushed() + 1 ); // 2. calc stream index from abs_seqno auto first_index = message.SYN ? 0 : abs_seqno - 1; reassembler_.insert( first_index, message.payload, message.FIN );}TCPReceiverMessage TCPReceiver::send() const{ TCPReceiverMessage msg; if ( has_error() ) { msg.RST = true; } auto window_size = writer().available_capacity(); msg.window_size = window_size &gt; UINT16_MAX ? UINT16_MAX : window_size; if ( isn_.has_value() ) { const auto abs_seqno = writer().bytes_pushed() + 1 + writer().is_closed(); msg.ackno = Wrap32::wrap( abs_seqno, isn_.value() ); } else { msg.ackno = nullopt; } return msg;}发送器(Sender)发送器与接收器一样都按照 fsm 设计，根据当前发送的 seq 以及ack 情况判断发送器的 fsm 是什么同时sender要肩负起维持数据传递的任务，所以当发送的 segment 长时间没有 ack(也就是出现超时情况，就要主动发送这些 segments, 在实际实现中存储在 outstanding_segments_ 中)使用定时器(Timer)判断当前是否超时，时间更新是通过外部提供(tick 方法接收), 从而进行判断。同时Timer对象应仅在需要时启动，不需要时关闭(outstanding_segments_不为空的时候就需要Timer计时).class TCPSender{public: /* Construct TCP sender with given default Retransmission Timeout and possible ISN */ TCPSender( ByteStream&amp;&amp; input, Wrap32 isn, uint64_t initial_RTO_ms ) : input_( std::move( input ) ), isn_( isn ), initial_RTO_ms_( initial_RTO_ms ), timer_(initial_RTO_ms) {} /* Generate an empty TCPSenderMessage */ TCPSenderMessage make_empty_message() const; /* Receive and process a TCPReceiverMessage from the peer's receiver */ void receive( const TCPReceiverMessage&amp; msg ); /* Type of the `transmit` function that the push and tick methods can use to send messages */ using TransmitFunction = std::function&lt;void( const TCPSenderMessage&amp; )&gt;; /* Push bytes from the outbound stream */ void push( const TransmitFunction&amp; transmit ); /* Time has passed by the given # of milliseconds since the last time the tick() method was called */ void tick( uint64_t ms_since_last_tick, const TransmitFunction&amp; transmit ); // Accessors uint64_t sequence_numbers_in_flight() const; // How many sequence numbers are outstanding? uint64_t consecutive_retransmissions() const; // How many consecutive *re*transmissions have happened? Writer&amp; writer() { return input_.writer(); } const Writer&amp; writer() const { return input_.writer(); } // Access input stream reader, but const-only (can't read from outside) const Reader&amp; reader() const { return input_.reader(); } void set_error() { input_.set_error(); }; bool has_error() const { return input_.has_error(); }private: // Variables initialized in constructor ByteStream input_; Wrap32 isn_; uint64_t initial_RTO_ms_; Timer timer_; uint64_t next_seq_no_ = 0; uint64_t window_size_ = 1; uint64_t retransmission_cnt_ = 0; uint64_t seq_no_in_flight_cnt_ = 0; bool syn_ {}; bool fin_ {}; std::queue&lt;TCPSenderMessage&gt; outstanding_segments_ = {};};uint64_t TCPSender::sequence_numbers_in_flight() const{ return seq_no_in_flight_cnt_;}uint64_t TCPSender::consecutive_retransmissions() const{ return retransmission_cnt_;}// 约定正常发送的 segment 一定是非空的(即一定是 SYN, FIN 或有 payload 的情况)// 发送的 segment 大小受接收窗口，可发送的数据大小以及 MAX_PAYLOAD_SIZE 的影响// 非正常情况下(RST, 此时则需要直接发送)void TCPSender::push( const TransmitFunction&amp; transmit ){ auto const cur_window_size = window_size_ ? window_size_ : 1u; while ( cur_window_size &gt;= sequence_numbers_in_flight() ) { auto const available_window = cur_window_size - sequence_numbers_in_flight(); auto msg = make_empty_message(); if(msg.RST){ transmit(msg); break; } if ( !syn_ ) syn_ = msg.SYN = true; auto const payload_size = min(min( TCPConfig::MAX_PAYLOAD_SIZE, available_window - msg.sequence_length()), reader().bytes_buffered()); read( input_.reader(), payload_size, msg.payload ); if ( !fin_ &amp;&amp; reader().is_finished() &amp;&amp; available_window &gt; msg.sequence_length() ) fin_ = msg.FIN = true; // when sequence_length == 0, which is meaningless message if (msg.sequence_length() == 0) break; // special case: FIN message cannot exceed receiver's window if ( msg.FIN &amp;&amp; available_window &lt; msg.sequence_length() ) fin_ = msg.FIN = false; const auto size = msg.sequence_length(); seq_no_in_flight_cnt_ += size; next_seq_no_ += size; outstanding_segments_.push( msg ); transmit( msg ); if ( !timer_.is_running() ) { timer_.start(); } } if(outstanding_segments_.empty()) timer_.stop();}TCPSenderMessage TCPSender::make_empty_message() const{ return { Wrap32::wrap( next_seq_no_, isn_ ), {}, {}, {}, has_error()};}// TCP receive 的都应是对端发送的 ACK segvoid TCPSender::receive( const TCPReceiverMessage&amp; msg ){ window_size_ = msg.window_size; if ( msg.RST ) { set_error(); timer_.stop(); } // error state, don't do any thing! if ( has_error() ) return; // no any ackno is meaningless for sender if ( !msg.ackno.has_value() ) return; auto const received_abs_ack_no = msg.ackno-&gt;unwrap( isn_, next_seq_no_ ); if ( received_abs_ack_no &gt; next_seq_no_ ) return; // Now we got the newest msg to update current state // check if any outstanding segments already received. bool success = false; while ( outstanding_segments_.size() ) { auto&amp; front_seg = outstanding_segments_.front(); // front seg still not sent to peer successfully if ( front_seg.seqno.unwrap( isn_, next_seq_no_ ) + front_seg.sequence_length() &gt; received_abs_ack_no ) break; seq_no_in_flight_cnt_ -= front_seg.sequence_length(); outstanding_segments_.pop(); success = true; } if ( success ) { timer_.reset_RTO(); retransmission_cnt_ = 0; timer_.start(); } if ( outstanding_segments_.empty() ) timer_.stop();}// 根据timer判断发送的segment 是否超时，并进行重传操作和统计重传次数void TCPSender::tick( uint64_t ms_since_last_tick, const TransmitFunction&amp; transmit ){ timer_.tick( ms_since_last_tick ); // send the oldest outstanding segment when timer is expired if ( timer_.is_expired() ) { transmit( outstanding_segments_.front() ); if ( window_size_ != 0 ) { ++retransmission_cnt_; timer_.double_RTO(); } timer_.start(); }}连接器(Connection)连接器中同时有 sender 和 receiver 两个实体，而Connection 自身不需要实现这两个实体的功能，而是更多关注在连接相关的事务： 主动与对端建立连接，关闭连接，同时支持被动关闭连接. 实现 CLOSED_WAIT 状态，这里我们实现的超时时长为 10 * rt_time, 也就是关闭连接的一段时间还需要再等等，对端可能还有最后的数据没发(继续向对端发送ack seg). 实现捎带机制：每次需要发送 ack seg 前，我们都尝试将 acked 部分放入sender将要发送的seg 中(sender的seg ack部分必然为空), 减少额外的发送 seg 量，将发送的 seg 变为 SEQ+ACK seg. 当然 sender 没有要发送的 seg 我们就只能手动创建一个 ACK seg. 主动处理异常状态：本端 bytestream 设置为 error 状态或者对端发送的 seg 中带有 RST 时，可以计时将自身状态转变为 error 状态, 在之后本端要发送的 seg 都会被拦截并改发送为 RST seg, 同时也不再处理对端发送的 seg.//! \\brief A complete endpoint of a TCP connectionclass TCPConnection { private: TCPConfig _cfg; TCPReceiver _receiver{_cfg.recv_capacity}; TCPSender _sender{_cfg.send_capacity, _cfg.rt_timeout, _cfg.fixed_isn}; //! outbound queue of segments that the TCPConnection wants sent std::queue&lt;TCPSegment&gt; _segments_out{}; //! Should the TCPConnection stay active (and keep ACKing) //! for 10 * _cfg.rt_timeout milliseconds after both streams have ended, //! in case the remote TCPConnection doesn't know we've received its whole stream? bool _linger_after_streams_finish{true}; size_t _time_since_last_segment_received{}; bool _active{true}; private: //! \\brief Every time send outbound seg, try to make up ACK part if possible void _send_with_ack_if_possible(); void _set_rst_state(); public: //! \\name \"Input\" interface for the writer //!@{ //! \\brief Initiate a connection by sending a SYN segment void connect(); //! \\brief Write data to the outbound byte stream, and send it over TCP if possible //! \\returns the number of bytes from `data` that were actually written. size_t write(const std::string &amp;data); //! \\returns the number of `bytes` that can be written right now. size_t remaining_outbound_capacity() const; //! \\brief Shut down the outbound byte stream (still allows reading incoming data) void end_input_stream(); //!@} //! \\name \"Output\" interface for the reader //!@{ //! \\brief The inbound byte stream received from the peer ByteStream &amp;inbound_stream() { return _receiver.stream_out(); } //!@} //! \\name Accessors used for testing //!@{ //! \\brief number of bytes sent and not yet acknowledged, counting SYN/FIN each as one byte size_t bytes_in_flight() const; //! \\brief number of bytes not yet reassembled size_t unassembled_bytes() const; //! \\brief Number of milliseconds since the last segment was received size_t time_since_last_segment_received() const; //!&lt; \\brief summarize the state of the sender, receiver, and the connection TCPState state() const { return {_sender, _receiver, active(), _linger_after_streams_finish}; }; //!@} //! \\name Methods for the owner or operating system to call //!@{ //! Called when a new segment has been received from the network void segment_received(const TCPSegment &amp;seg); //! Called periodically when time elapses void tick(const size_t ms_since_last_tick); //! \\brief TCPSegments that the TCPConnection has enqueued for transmission. //! \\note The owner or operating system will dequeue these and //! put each one into the payload of a lower-layer datagram (usually Internet datagrams (IP), //! but could also be user datagrams (UDP) or any other kind). std::queue&lt;TCPSegment&gt; &amp;segments_out() { return _segments_out; } //! \\brief Is the connection still alive in any way? //! \\returns `true` if either stream is still running or if the TCPConnection is lingering //! after both streams have finished (e.g. to ACK retransmissions from the peer) bool active() const; //!@} //! Construct a new connection from a configuration explicit TCPConnection(const TCPConfig &amp;cfg) : _cfg{cfg} {} //! \\name construction and destruction //! moving is allowed; copying is disallowed; default construction not possible //!@{ ~TCPConnection(); //!&lt; destructor sends a RST if the connection is still open TCPConnection() = delete; TCPConnection(TCPConnection &amp;&amp;other) = default; TCPConnection &amp;operator=(TCPConnection &amp;&amp;other) = default; TCPConnection(const TCPConnection &amp;other) = delete; TCPConnection &amp;operator=(const TCPConnection &amp;other) = delete; //!@}};size_t TCPConnection::remaining_outbound_capacity() const { return _sender.stream_in().remaining_capacity(); }size_t TCPConnection::bytes_in_flight() const { return _sender.bytes_in_flight(); }size_t TCPConnection::unassembled_bytes() const { return _receiver.unassembled_bytes(); }size_t TCPConnection::time_since_last_segment_received() const { return _time_since_last_segment_received; }void TCPConnection::segment_received(const TCPSegment &amp;seg) { _time_since_last_segment_received = 0; const auto &amp;header = seg.header(); if(header.rst){ _set_rst_state(); return; } bool need_empty_seg = seg.length_in_sequence_space() &gt; 0; _receiver.segment_received(seg); if(header.ack){ _sender.ack_received(header.ackno, header.win); if(need_empty_seg &amp;&amp; !_sender.segments_out().empty()){ need_empty_seg = false; } } // _receiver LISTEN -&gt; SYN_RECV state if( TCPState::state_summary(_sender) == TCPSenderStateSummary::CLOSED &amp;&amp; TCPState::state_summary(_receiver) == TCPReceiverStateSummary::SYN_RECV){ connect(); return; } // _receiver FIN_RECV -&gt; PASSIVE close (CLOSE WAIT) if( TCPState::state_summary(_sender) == TCPSenderStateSummary::SYN_ACKED &amp;&amp; TCPState::state_summary(_receiver) == TCPReceiverStateSummary::FIN_RECV){ _linger_after_streams_finish = false; } // PASSIVE close if( !_linger_after_streams_finish &amp;&amp; TCPState::state_summary(_sender) == TCPSenderStateSummary::FIN_ACKED &amp;&amp; TCPState::state_summary(_receiver) == TCPReceiverStateSummary::FIN_RECV){ _active = false; return; } // keep-alive if( _receiver.ackno().has_value() &amp;&amp; seg.length_in_sequence_space() == 0 &amp;&amp; _receiver.ackno().value() - 1 == seg.header().seqno){ need_empty_seg = true; } if(need_empty_seg) _sender.send_empty_segment(); _send_with_ack_if_possible();}bool TCPConnection::active() const { return _active; }size_t TCPConnection::write(const string &amp;data) { auto write_size = _sender.stream_in().write(data); _sender.fill_window(); _send_with_ack_if_possible(); return write_size;}//! \\param[in] ms_since_last_tick number of milliseconds since the last call to this methodvoid TCPConnection::tick(const size_t ms_since_last_tick) { _time_since_last_segment_received += ms_since_last_tick; _sender.tick(ms_since_last_tick); // maximum retry time limit if(_sender.consecutive_retransmissions() &gt; TCPConfig::MAX_RETX_ATTEMPTS){ while(segments_out().size()) segments_out().pop(); _set_rst_state(); TCPSegment seg; seg.header().rst = true; seg.header().seqno = _sender.next_seqno(); segments_out().emplace(std::move(seg)); return; } _send_with_ack_if_possible(); // ACTIVE CLOSE if( _linger_after_streams_finish &amp;&amp; TCPState::state_summary(_sender) == TCPSenderStateSummary::FIN_ACKED &amp;&amp; TCPState::state_summary(_receiver) == TCPReceiverStateSummary::FIN_RECV &amp;&amp; _time_since_last_segment_received &gt;= 10 * _cfg.rt_timeout){ _active = false; _linger_after_streams_finish = false; }}void TCPConnection::end_input_stream() { // _sender convert to FIN_SENT state _sender.stream_in().end_input(); _sender.fill_window(); _send_with_ack_if_possible();}void TCPConnection::connect() { if (TCPState::state_summary(_sender) == TCPSenderStateSummary::CLOSED) { _sender.fill_window(); _send_with_ack_if_possible(); }}void TCPConnection::_send_with_ack_if_possible() { while (_sender.segments_out().size()) { auto &amp;&amp;seg = _sender.segments_out().front(); // If seg's ACK part is blank, we try to add it if (_receiver.ackno().has_value()) { seg.header().ack = true; seg.header().ackno = _receiver.ackno().value(); seg.header().win = std::min(_receiver.window_size(), static_cast&lt;size_t&gt;(UINT16_MAX)); } segments_out().emplace(std::move(seg)); _sender.segments_out().pop(); }}void TCPConnection::_set_rst_state() { _sender.stream_in().set_error(); _receiver.stream_out().set_error(); _linger_after_streams_finish = false; _active = false;}TCPConnection::~TCPConnection() { try { if (active()) { cerr &lt;&lt; \"Warning: Unclean shutdown of TCPConnection\\n\"; // Your code here: need to send a RST segment to the peer _set_rst_state(); TCPSegment seg; seg.header().rst = true; seg.header().seqno = _sender.next_seqno(); _segments_out.emplace(std::move(seg)); } } catch (const exception &amp;e) { std::cerr &lt;&lt; \"Exception destructing TCP FSM: \" &lt;&lt; e.what() &lt;&lt; std::endl; }}" }, { "title": "DH算法及TLS/1.2/1.3握手", "url": "/posts/%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95/", "categories": "基础, 网络", "tags": "基础", "date": "2024-09-07 17:31:00 +0800", "snippet": "DH 算法该算法用于协商并计算对称秘钥，所基于的原理为计算离散对数的难度远大于计算模p指数。离散对数：有等式 $a^i (mod\\ p) == b$, 其中 i 为 b 的以a为底的模 p 对数。如果给定任意的底数G, 质数P以及指数a, 大写的可公开，小写不可公开，可轻易计算模P指数：$G^a (mod\\ P) \\rightarrow A$而给定底数G, 模数P以及公开的A，则难以计算 a...", "content": "DH 算法该算法用于协商并计算对称秘钥，所基于的原理为计算离散对数的难度远大于计算模p指数。离散对数：有等式 $a^i (mod\\ p) == b$, 其中 i 为 b 的以a为底的模 p 对数。如果给定任意的底数G, 质数P以及指数a, 大写的可公开，小写不可公开，可轻易计算模P指数：$G^a (mod\\ P) \\rightarrow A$而给定底数G, 模数P以及公开的A，则难以计算 a:$G^? (mod\\ P) \\leftarrow A$所以DH算法可借助该原理交换秘钥： 公共部分的选择：双方首先约定一个公用的素数 p 和一个基数 g; 生成私钥： A方选择一个私有的随机数 a, 并计算 $A = g ^ a mod\\ p$ 作为公钥; B方选择一个私有的随机数 b, 并计算 $B = g ^ b mod\\ p$ 作为公钥; 通过信道A B双方交换各自的公钥A, B; 计算对称秘钥： A接收到B方的公钥，计算对称密钥 $K = B ^ a mod\\ p$; B接收到A方的公钥，并计算对称秘钥 $K’ = A ^ b mod\\ p$;两方计算的对称秘钥是相等的: $K = B ^ a mod\\ p = g ^{ab} mod\\ p = A ^ b mod\\ p = K’$ 根据私钥生成的随机性也可分为：static DH 算法和 DHE 算法，其中 static DH 算法中一方的私钥固定不会发生改变，而 DHE 算法双方的秘钥都是随机生成的。所以 static DH 算法一旦被破解出固定私钥，其他所有通信的内容都会被破解；而 DHE 即便有一次通信的私钥被破解，其他的通信仍然是安全的。我们称 static DH算法不具有前向安全性，也即长期下来秘钥被破解，也不会影响过去的通信内容，保护过去的通信内容不被破解。ECDHE 算法该算法相比 DHE 算法需要计算指数取模，运算量较大的缺点，采用 ECC 椭圆，根据约定的共享椭圆参数，并根据基点计算代替离散对数运算，可以大幅降低运算量的同时达到相同的目的，且该算法也具有前向安全性。算法过程与 DHE 相似： 双方约定公共的椭圆参数，以及曲线基点G； 生成私钥： A方选择一个私有的随机数 a, 并计算 $A = aG$ 作为公钥; B方选择一个私有的随机数 b, 并计算 $B = bG$ 作为公钥; 通过信道A B双方交换各自的公钥A, B; 计算对称秘钥： A接收到B方的公钥，计算对称密钥 $K = aB$; B接收到A方的公钥，并计算对称秘钥 $K’ = bA$;两方计算的共享坐标 $(x,y)$ 是中的横坐标 x 是相等的，K 则为共享点，x 为对称秘钥 ECDHE 算法则广泛用于 TLS 1.2/1.3 握手过程协商对称密钥。基于 ECDHE 算法的 TLS 1.2 握手过程首先，两端通过TCP构建连接，并在完成连接后(三次握手后)开始TLS握手，在 Wireshark 中可以看到在TCP第三次握手时，客户端就开始向服务端发送TLS ClientHello 消息，这是因为TCP发送segment的捎带机制会在发送tcp消息时插入ACK，节省时间和空间。TLS 握手由四步构成(这里使用ECDHE算法协商秘钥)： Client Hello: 客户端发送TLS握手，提供: 客户端支持的加密套件; 客户端随机数; Server Hello, Certificate, Server key exchange, Server Hello Done: 服务端发送并提供： Server Hello: 服务端选择的加密套件, 服务端随机数; Certificate: 服务端证书; Server key exchange: 服务端提供EC曲线的参数，ECDHE的服务端公钥(该公钥采用RSA签名); Server Hello Done; Client key exchange, Change cipher spec, Encrypted handshake message: 客户端发送： Client key exchage: 根据服务端发送的EC曲线参数发送ECDHE的客户端公钥 Change cipher spec: 告知对端后续消息会切换加密，采用对称加密算法 Encrypted handshake message: 将前面发送的消息做摘要，并用对称密钥加密，用于服务端进行验证 Change cipher spec, Encrypted handshake message: 服务端验证完毕也发送相同的内容提供给客户端验证.备注： 客户端可以在握手3到4步之间就开始发送http内容，这种行为称作 TLS False start; ECDHE 计算出的秘钥 x 并不直接作为对称密钥，而是同时使用客户端和服务端的随机数以及x共同计算出对称密钥，可大幅降低被黑客攻击的几率；TLS 1.3 握手过程后面再补。参考文章：1 小林coding的TLS解释" }, { "title": "杂记", "url": "/posts/%E6%9D%82%E8%AE%B0/", "categories": "杂项", "tags": "杂项", "date": "2024-09-04 18:04:00 +0800", "snippet": "《隐形守护者》中肖途这位战士，忍辱负重，抹除过去的自己，投身于民族复兴重任，保留自己汉奸的名声，并不断透露给后方情报。中途经历队友倒戈，自己却总能够以读者意想不到的方式绝处逢生。这样的行为确实大义。记得在黑神话悟空中第一章结尾，黑熊精问菩萨为何金池长老如此在意那一件袈裟？菩萨大士回道：“若不披上这件衣裳，众生又怎知我尘缘已断、金海尽干？”。这里原句已让我震撼不已，而当这一句话放在肖途的身上，...", "content": "《隐形守护者》中肖途这位战士，忍辱负重，抹除过去的自己，投身于民族复兴重任，保留自己汉奸的名声，并不断透露给后方情报。中途经历队友倒戈，自己却总能够以读者意想不到的方式绝处逢生。这样的行为确实大义。记得在黑神话悟空中第一章结尾，黑熊精问菩萨为何金池长老如此在意那一件袈裟？菩萨大士回道：“若不披上这件衣裳，众生又怎知我尘缘已断、金海尽干？”。这里原句已让我震撼不已，而当这一句话放在肖途的身上，才更能反衬出为民族大义，为国家崛起的爱国精神，不是抗日英雄这件袈裟所能桎梏，作为中国人，成为隐形的守护者。简单记录一下现在的感受。" }, { "title": "Manacher算法", "url": "/posts/manacher/", "categories": "算法, 动态规划", "tags": "算法, 动态规划", "date": "2024-08-13 14:41:00 +0800", "snippet": "很多年以前看过的回文串计算，当时只了解到中心扩展，最近突然看到一篇很好的视频，深入浅出讲解了Manacher算法具体来说，该方法在 中心扩展算法 的基础上，进一步利用回文串性质，使求回文子串问题的复杂度从 $O(n^2) \\rightarrow O(n)$其关键思想为：通过上述根据前面内容推导结果，可以大幅减少 需要扩展的次数, 所以原先扩展的复杂度可以降低至 $O(n)$.class So...", "content": "很多年以前看过的回文串计算，当时只了解到中心扩展，最近突然看到一篇很好的视频，深入浅出讲解了Manacher算法具体来说，该方法在 中心扩展算法 的基础上，进一步利用回文串性质，使求回文子串问题的复杂度从 $O(n^2) \\rightarrow O(n)$其关键思想为：通过上述根据前面内容推导结果，可以大幅减少 需要扩展的次数, 所以原先扩展的复杂度可以降低至 $O(n)$.class Solution {public: int countSubstrings(string s) { ostringstream oss; oss &lt;&lt; \"^#\"; for(auto c : s){ oss &lt;&lt; c &lt;&lt; '#'; } oss &lt;&lt; '$'; string manacher = oss.str(); // cout &lt;&lt; manacher &lt;&lt; '\\n'; int n = manacher.size(); vector&lt;int&gt; f(n, 0); int r = 0, c = 0; for(int i = 1; i &lt; n - 1; i++){ if(i &lt;= r) f[i] = min(r - i, f[2 * c - i]); while(i + f[i] + 1 &lt; n &amp;&amp; i - f[i] - 1 &gt;= 0 &amp;&amp; manacher[i + f[i] + 1] == manacher[i - f[i] - 1]) f[i]++; if(i + f[i] &gt; r){ c = i; r = f[i] + i; } } // cout &lt;&lt; f &lt;&lt; '\\n'; int res = 0; for(int i = 0; i &lt; n; i++) res += (f[i] + 1 &gt;&gt; 1); return res; }};" }, { "title": "一些常识性内容的积累", "url": "/posts/%E9%9D%A2%E8%AF%95/", "categories": "基础", "tags": "Linux, 算法, 面试", "date": "2024-08-11 14:28:00 +0800", "snippet": "这里记录常见的面试，包括网友的面经以及自己的面试问题。算法面试堆排序的原理？怎么实现？堆排序指：维护一个树形结构，使其所有父子节点之间满足一条件。实现：对于堆排序，只需要实现 down 和 up 操作，其中 down指定其中一个节点递归地与子节点比较，交换不满足条件的父子节点。例子：我们如果想要实现的关系为大顶堆(树形结构根部值最大，所有父子节点满足父节点&gt;子节点)// 节点编号从1开...", "content": "这里记录常见的面试，包括网友的面经以及自己的面试问题。算法面试堆排序的原理？怎么实现？堆排序指：维护一个树形结构，使其所有父子节点之间满足一条件。实现：对于堆排序，只需要实现 down 和 up 操作，其中 down指定其中一个节点递归地与子节点比较，交换不满足条件的父子节点。例子：我们如果想要实现的关系为大顶堆(树形结构根部值最大，所有父子节点满足父节点&gt;子节点)// 节点编号从1开始// using entry = AnyEntry with comparative operator implementedusing entry = int;entry heap[N], size;// O(logN)void down(int i){ int t = i; if(2 * i &lt;= size &amp;&amp; heap[2 * i] &lt; heap[t]) t = 2 * i; if(2 * i + 1&lt;= size &amp;&amp; heap[2 * i + 1] &lt; heap[t]) t = 2 * i + 1; if(t != i){ swap(heap[i], heap[t]); down(t); }}// O(logN)void up(int i){ int t = i / 2; while(t &amp;&amp; heap[i] &gt; heap[t]){ swap(heap[i], heap[t]); i = t; t = t / 2; }}如果要建堆，也可以用上面的方法实现，复杂度为O(N)// 访问所有非叶子节点，因为我们使用的底层存储时连续数组，所以可以直接将当前数组当作完全二叉树，那么非叶子节点最后一位就在 n / 2 处(最后一个节点的父节点)void build_heap(int size){ // 起始点为 1, 下标0空置方便进行处理 for(int i = size / 2; i &gt;= 1; i--){ down(i); }}口头描述思路 ：镜像翻转二叉树镜像反转二叉树可以用递归的思想实现，然后处理边界情况即可，也就是，先镜像反转左子树，再镜像反转右子树，最后交换左右子树的指针或引用。使用非递归的方法实现，因为要先反转子树，然后交换子树的指针，所以需要手动添加一个栈保存我们最后回来要执行的反转操作。如果要手撕想一想就可以了:/** * struct TreeNode { *\tint val; *\tstruct TreeNode *left; *\tstruct TreeNode *right; *\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * }; */// 递归实现TreeNode* Mirror(TreeNode* pRoot) { // write code if(pRoot == nullptr) return nullptr; Mirror(pRoot-&gt;left); Mirror(pRoot-&gt;right); std::swap(pRoot-&gt;left, pRoot-&gt;right); return pRoot;}// 非递归实现TreeNode* Mirror(TreeNode* pRoot) { // write code if(pRoot == nullptr) return nullptr; stack&lt;TreeNode *&gt; st; st.push(pRoot); while(st.size()){ auto ptr = st.top(); if(ptr == nullptr){ st.pop(); }else{ std::swap(ptr-&gt;left, ptr-&gt;right); st.pop(); st.push(ptr-&gt;left); st.push(ptr-&gt;right); } cout &lt;&lt; st.size() &lt;&lt; '\\n'; } return pRoot;}memcpy实现即实现 void *memcpy(void *dest, const void *src, size_t n)该函数要求不能有重叠内存地址范围，否则会发生未定义的行为：void *memcpy(void *dest, const void *src, size_t n){ // dest 和 src 都是类型擦除的指针类型 // 我们后续处理都按照字节为单位进行处理 auto d = reinterpret_cast&lt;uint8_t *&gt;(dest); const auto s = reinterpret_cast&lt;const uint8_t *&gt;(src); assert((s + n &lt; d) || (d + n &lt; s)); for(size_t i = 0; i &lt; n; i++) d[i] = s[i]; return dest;}优化？优化这一部分，从拷贝操作出发，我们可以根据操作系统为 64位或32位，而使用uint64_t 或 uint32_t 来拷贝多个字节，或者使用SIMD一般面试常识DNS是什么，在网络通信中的作用是什么？DNS全程为域名服务，用来提供将域名转换为ip地址的服务，降低web用户访问服务器的记忆门槛。ICMP协议知道吗，哪一层的干什么的ICMP 是网络层协议，用来发送错误信息，例如：”目标不可达”, “超时”等消息，PING 基于该协议开发。拷贝和深拷贝的区别，写一个类展现二者的区别浅拷贝仅拷贝引用或指针，而不重新开辟对应的存储空间:struct A { int *ptr = nullptr; A(int *ptr) : ptr(ptr) {} A() = default; A(const A &amp;that) { ptr = new int(*that.ptr); } A(A &amp;&amp;that) : ptr(that.ptr) { that.ptr = nullptr; }};int main() { int num = 3; A a(&amp;num); A b = a; cout &lt;&lt; a.ptr &lt;&lt; '\\n'; cout &lt;&lt; &amp;a.ptr &lt;&lt; '\\n'; cout &lt;&lt; *a.ptr &lt;&lt; '\\n'; cout &lt;&lt; b.ptr &lt;&lt; '\\n'; cout &lt;&lt; &amp;b.ptr &lt;&lt; '\\n'; cout &lt;&lt; *b.ptr &lt;&lt; '\\n';/* 0x7ffe131f9304 0x7ffe131f9308 3 0x558445abd2b0 0x7ffe131f9310 3 */ return 0;}如果我们使用浅拷贝，就会只传递对应的指针值，如果需要实际深拷贝，应该重新构造对应的变量。常用的C++11的特性 智能指针：解释一下智能指针包括什么? shared_ptr, weak_ptr, unique_ptr, 其中 shared_ptr 内部使用引用计数判断是否析构管理的指针，计数为0时才会真正使用默认 delete; weak_ptr 用于解决 shared_ptr 循环引用的问题; unique_ptr 实现了独占资源的资源指针管理，且容器不支持拷贝构造和拷贝赋值; 自动推导变量类型: auto 可以编译期的时候根据初始化的表达式推断最终的值类型是什么，要求使用 auto 的变量必须初始化，否则推导失败，不能通过编译；以及 decltype() 推导实体或者表达式的值类型； 改进的迭代器：可以使用统一的标准访问可迭代对象, begin, end, prev, next 一些常用库的封装: pthread.h-&gt;thread, 高精度时间库 chrono 新增了预置函数(=default)和弃置函数(=delete) 函数容器库: std::function 新增了移动构造和移动赋值 lambda表达式范围 for软件使用Linux系统用什么指令查看路由表ip route 或 routeLinux系统中的signal机制，常见的signal类型，程序崩溃的signal类型使用软件kill可以发送信号，默认信号是SIGKILL, 常见的signal类型包括：SIGKILL, SIGINT, SIGHUP(我能立即想起来的就是这三个), IO相关的(SIGPIPE)wireshark用过吗？它能实现抓包功能的核心原理是什么？创建虚拟网关，使本地网络所有入口和出口都需要经过 wireshark, 实现捕获流量进行抓包的功能。赛马问题(64匹马，8赛道，最少需要几轮确认前4名)C++中的volatile作用我们一般情况下很少使用该关键字，是因为我们会假设当前程序中的全局变量默认仅当前进程使用，不会受到外部程序干扰，所以编译器在一些情况会主动修改部分变量(也叫优化).例如:int some_int = 100;while(some_int == 100){ // code}但是整个程序中未对 some_int 做任何修改，那么编译器在优化等级较高的情况下会将代码while(some_int == 100) 优化为 while(true), 但是某些情况下，其他的程序会修改 some_int 而编译器无法发现，这就会造成错误的优化，导致不可知情况。为了避免如此情况发生，就可以使用关键字 volatile 要求编译器不对该情况进行优化。volatile int some_int = 100;这样编译器就知道：some_int 可能会被其他的程序修改，那不能对相关的代码做错误优化。参考链接: Why do we use the volatile keyword联合索引的特点 最左优先匹配 全表匹配所有列包含在联合索引内，则直接使用联合索引进行遍历RPC的原理数据库的主键是什么，在数据库中的作用是什么个人情况学习路线遇到的困难反问问题这些问题都比较好，可以提前了解公司的情况，以及岗位实际的需求。1.您希望这个岗位的面试者具备什么样的能力呢?2.团队人员规模有多大，各自是如何分工的?3.岗位的晋升路线是怎样的?4.未来的发展前景是怎样的?5.如果我有幸加入您负责的部门，您期望我能给团队带来哪些价值?6.培训机制、试用期转正、岗位新增还是替补，工作氛围等7.您认为我的面试表现在哪些方面有待改进呢？8.工作性质（工作多久具备承担新项目的能力?学习多久能进入新产品研发工作?），9.培训形式（新人培训的时间?培训的方式?是不是导师制?）10.公司规模（总规模多少人，研发部门多少人，机械结构多少人）11.我能获得什么锻炼提升的机会？参考链接" }, { "title": "stl-function 实现", "url": "/posts/stl-function/", "categories": "C++, stl容器", "tags": "C++, stl容器", "date": "2024-08-10 15:37:00 +0800", "snippet": "在C++中一个装饰器类，可承载任何可调用对象，包括 lambda表达式, func, func ptr, class with operator(), 且这样在编译时仅按照相同参数和返回来实例化一份模板，并不会因为是否为函数指针，函数以及可调用对象导致实例化多份. 实现一个这样的容器类最关键的地方在于类型擦除，即将任何可调用对象转为内部的FuncBase类的调用目标，通过 invoke 实现...", "content": "在C++中一个装饰器类，可承载任何可调用对象，包括 lambda表达式, func, func ptr, class with operator(), 且这样在编译时仅按照相同参数和返回来实例化一份模板，并不会因为是否为函数指针，函数以及可调用对象导致实例化多份. 实现一个这样的容器类最关键的地方在于类型擦除，即将任何可调用对象转为内部的FuncBase类的调用目标，通过 invoke 实现只关心参数及返回，并通过模板子类实现自动实例化需要被包装的可调用对象，这样一个最基本的结构应该是：// 对外暴露模板参数应只关注调用对象的 `签名`, 也即返回值类型和参数包template&lt;class Ret, class ...Args&gt;struct function {};那么如果传入的模板参数非法怎么办? 这里可以重新定义模板，使得编译器不能通过重载决议的情况退回默认模板：// 默认情况，满足上述的模板会变为下述情况，并直接编译器报错// 明确我们的容器只接受指定为返回值和参数的函数，其他的情况都为错误情况template&lt;class Fn&gt;struct function { static_assert(!std::is_function_v&lt;Fn&gt;, \"Not a valid Function\");}// 而我们实现的版本则使用偏特化，表示我们接收的是一种函数template&lt;class Ret, class ...Args&gt;struct function&lt;Ret(Args...)&gt; { }为了实现类型擦除，我们应该采用虚函数的方式实现，或者说多态技术:// ...template&lt;class Ret, class ...Args&gt;struct function&lt;Ret(Args)&gt; { // 这一类可调用对象都使用FuncBase call 进行实际调用 struct FuncBase { virtual _call(Args...) = 0; virtual ~FuncBase() = default; } // 加入额外模板参数，用来存储外部的可调用对象 template&lt;class = std::enable_if_t&lt; std::is_constructible_v&lt;F, Args...&gt; &amp;&amp; std::is_same_v&lt;std::invoke_result_t&lt;std::decay_t&lt;F&gt;, Args...&gt;, Ret&gt; &gt;&gt; struct FuncImpl : FuncBase { F m_func; Ret _call(Args &amp;&amp;...args) override { return std::invoke(m_func, std::forward&lt;Args&gt;(args)...); } FuncImpl(F &amp;&amp;f) : m_func(std::forward(f)) {} } // 对于function来说，任务是接收外部可调用对象，同时提供调用接口 template &lt;class F, class = std::enable_if_t&lt; std::is_invocable_r_v&lt;Ret, F, Args...&gt; &amp;&amp; !std::is_same_v&lt;std::decay_t&lt;F&gt;, Function&gt;&gt;&gt; function(F &amp;&amp;f) : m_func(std::make_shared&lt;FuncImpl&lt;std::decay_t(F)&gt;&gt;(std::forward&lt;std::decay_t(F)&gt;(f))) {} Ret operator()(Args &amp;&amp;...args) { return m_func-&gt;_call(std::forward&lt;Args&gt;(args)...); } std::shared_ptr&lt;FuncBase&gt; m_func;}这样，一个支持可调用对象的function容器就可以完成基本的任务了, 现在我们可以测试一下常见的集中可调用对象:int func1(int a) { cout &lt;&lt; \"func what = \" &lt;&lt; a &lt;&lt; '\\n'; return a;}struct obj { static int obj_func(int a) { cout &lt;&lt; \"obj func what = \" &lt;&lt; a &lt;&lt; '\\n'; return a; }};int main() { // func function&lt;int(int)&gt; func = func1; auto ret = func(1); cout &lt;&lt; \"output = \\\"\" &lt;&lt; ret &lt;&lt; \"\\\"\\n\"; // func ptr function&lt;int(int)&gt; func_ptr = &amp;func1; ret = func_ptr(2); cout &lt;&lt; \"output = \\\"\" &lt;&lt; ret &lt;&lt; \"\\\"\\n\"; // obj func function&lt;int(int)&gt; func_obj = obj::obj_func; ret = func_obj(3); cout &lt;&lt; \"output = \\\"\" &lt;&lt; ret &lt;&lt; \"\\\"\\n\"; // obj func ptr function&lt;int(int)&gt; func_obj_ptr = &amp;obj::obj_func; ret = func_obj_ptr(4); cout &lt;&lt; \"output = \\\"\" &lt;&lt; ret &lt;&lt; \"\\\"\\n\"; function&lt;int(int)&gt; func_lambda = [](int a) { cout &lt;&lt; \"lambda what = \" &lt;&lt; a &lt;&lt; '\\n'; return a; }; ret = func_lambda(5); cout &lt;&lt; \"output = \\\"\" &lt;&lt; ret &lt;&lt; \"\\\"\\n\"; return 0;}/* 输出结果: &gt; func what = 1&gt; output = \"1\"&gt; func what = 2&gt; output = \"2\"&gt; obj func what = 3&gt; output = \"3\"&gt; obj func what = 4&gt; output = \"4\"&gt; lambda what = 5&gt; output = \"5\" */看起来一切都正常，那如果我们想让该容器实现模板参数自动推导呢，也就是CTAD的特性，按照我们使用常见容器的方式，只要把类型中的模板参数留空，就可以自动推导：int func1(int a) { cout &lt;&lt; \"func what = \" &lt;&lt; a &lt;&lt; '\\n'; return a;}int main(){ function func = func1; // 编译出错 class template argument deduction failed:}出现了错误，看一下错误原因，是我们类模板参数推导不出来，这里我们试着给他提供一下推导指南吧:template&lt;class F&gt; //我们传入的参数是什么来着？就是一个可调用对象struct function(F) -&gt; function&lt;???&gt;;// 我们需要传入的是一个F对象，推导的是F对应的函数签名，需要使用额外的辅助萃取出对应类型template &lt;class F&gt; struct function_traits;template &lt;class R, class... Args&gt; struct function_traits&lt;R(Args...)&gt; { using type = R(Args...);};template &lt;class R, class... Args&gt; struct function_traits&lt;R (*)(Args...)&gt; { using type = R(Args...);};template &lt;class C, class R, class... Args&gt;struct function_traits&lt;R (C::*)(Args...)&gt; { using type = R(Args...);};template &lt;class C, class R, class... Args&gt;struct function_traits&lt;R (C::*)(Args...) const&gt; { using type = R(Args...);};// 可调用对象的类型也即 operator() 函数的类型template &lt;class F&gt; struct function_traits { using fn_type = std::decay_t&lt;decltype(&amp;F::operator())&gt;; using type = typename function_traits&lt;fn_type&gt;::type;};template &lt;class F&gt; function(F) -&gt; function&lt;typename function_traits&lt;F&gt;::type&gt;;template&lt;class F&gt; //我们传入的参数是什么来着？就是一个可调用对象，现在可以使用类型萃取的方式从 F 中获取我们需要的内容struct function(F) -&gt; function&lt;function_traits&lt;F&gt;::type&gt;;正好再和标准库学习一下，给一个 function_traits_t 别名吧：template&lt;class F&gt;using function_traits_t = typename function_traits&lt;F&gt;::type;// 这样我们的推导指南可以写成template&lt;class F&gt;function(F) -&gt; function&lt;function_traits_t&lt;F&gt;&gt;;提供了类型推导指南后，我们就可以开开心心地让编译器帮我们推导出来具体的模板参数，而不需要我们手动指明：void test() { // func function func = func1; auto func_sig = func1; auto ret = func(1); cout &lt;&lt; \"output = \\\"\" &lt;&lt; ret &lt;&lt; \"\\\"\\n\"; // func ptr function func_ptr = &amp;func1; auto func_ptr_sig = &amp;func1; ret = func_ptr(2); cout &lt;&lt; \"output = \\\"\" &lt;&lt; ret &lt;&lt; \"\\\"\\n\"; obj obj_instance; // obj func function func_obj = obj::obj_func; auto func_obj_sig = &amp;obj::obj_func; ret = func_obj(3); cout &lt;&lt; \"output = \\\"\" &lt;&lt; ret &lt;&lt; \"\\\"\\n\"; // obj func ptr function func_obj_ptr = &amp;obj::obj_func; auto func_obj_ptr_sig = &amp;obj::obj_func; ret = func_obj_ptr(4); cout &lt;&lt; \"output = \\\"\" &lt;&lt; ret &lt;&lt; \"\\\"\\n\"; function func_lambda = [](int a) { cout &lt;&lt; \"lambda what = \" &lt;&lt; a &lt;&lt; '\\n'; return a; }; ret = func_lambda(5); cout &lt;&lt; \"output = \\\"\" &lt;&lt; ret &lt;&lt; \"\\\"\\n\";}int main() { test(); return 0;}可以看到，可以推导出常见的可调用对象。在本代码中没有提供移动和拷贝构造实现，因为function仅有 shared_ptr 管理的对象，这样我们使用默认的构造和移动函数就可以，全部交给 shared_ptr 管理即可。" }, { "title": "merge_sort", "url": "/posts/merge_sort/", "categories": "算法, 排序", "tags": "算法", "date": "2024-08-09 15:47:00 +0800", "snippet": "merge_sort也要有自己的非递归版本代码这个版本模仿后序遍历，问题在及其占用空间，复杂度在 $O(n^2)$, 所以仅供参考，实际不会这么实现。#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;us...", "content": "merge_sort也要有自己的非递归版本代码这个版本模仿后序遍历，问题在及其占用空间，复杂度在 $O(n^2)$, 所以仅供参考，实际不会这么实现。#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;const int N = 100010;int tmp[N];void merge_sort(int arr[], int l, int r){ if(l &gt;= r) return; vector&lt;int&gt; tmp(r - l + 1); int mid = l + r &gt;&gt; 1; merge_sort(arr, l, mid): merge_sort(arr, mid + 1, r): int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r){ if(arr[i] &lt; arr[j]) tmp[k++] = arr[i++]; else tmp[k++] = arr[j++]; } while(i &lt;= mid) tmp[k++] = arr[i++]; while(j &lt;= r) tmp[k++] = arr[j++]; for(int i = l, k = 0; i &lt;= r; i++, k++) arr[i] = tmp[k];}void merge_sort(int arr[], int l, int r){ if(l &gt;= r) return; using pii = pair&lt;int,int&gt;; stack&lt;pii&gt; s; vector&lt;vector&lt;bool&gt;&gt; st(r - l + 1, vector&lt;bool&gt;(r - l + 1, false)); vector&lt;int&gt; tmp(r - l + 1); s.push({l, r}); while(s.size()){ auto [l, r] = s.top(); if(l &gt;= r) { s.pop(); continue; } int mid = l + r &gt;&gt; 1; if(st[l][r]){ // 已经计算过子区间 int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r){ if(arr[i] &lt; arr[j]) tmp[k++] = arr[i++]; else tmp[k++] = arr[j++]; } while(i &lt;= mid) tmp[k++] = arr[i++]; while(j &lt;= r) tmp[k++] = arr[j++]; for(int i = l, k = 0; i &lt;= r; i++, k++) arr[i] = tmp[k]; s.pop(); }else{ s.push({l, mid}); s.push({mid + 1, r}); st[l][r] = true; } }}int main(){ int n; scanf(\"%d\", &amp;n); int arr[n]; for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;arr[i]); merge_sort(arr, 0, n - 1); for (int i = 0; i &lt; n; i++) printf(\"%d \", arr[i]); return 0;}正常的实现，从小到大迭代窗口，记得处理最右的一块不是2的整数次幂的情况。#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 100010;static vector&lt;int&gt; tmp(N);void merge_single(vector&lt;int&gt; &amp;arr, int l, int r, int mid, bool p = false){ if(l &gt;= r) return; int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r){ if(arr[i] &lt; arr[j]) tmp[k++] = arr[i++]; else tmp[k++] = arr[j++]; } while(i &lt;= mid) tmp[k++] = arr[i++]; while(j &lt;= r) tmp[k++] = arr[j++]; for(int i = l, k = 0; i &lt;= r; i++, k++) arr[i] = tmp[k];}void merge_sort(vector&lt;int&gt; &amp;arr, int l, int r){ if(l &gt;= r) return; int k = 2; for(; k &lt;= r - l + 1; k &lt;&lt;= 1){ for(int i = 0; i &lt;= r; i += k){ int j = min(r, i + k - 1), mid = i + (k &gt;&gt; 1) - 1; merge_single(arr, i, j, mid); } } merge_single(arr, l, r, (k &gt;&gt; 1) - 1, true);}int main(){ int n; cin &gt;&gt; n; vector&lt;int&gt; arr(n); for(int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i]; merge_sort(arr, 0, n - 1); for(int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; ' '; cout &lt;&lt; '\\n'; return 0;}" }, { "title": "quick_sort", "url": "/posts/quick_sort/", "categories": "算法, 排序", "tags": "算法", "date": "2024-08-07 21:03:00 +0800", "snippet": "很久没看过算法内容，今天逛了逛牛客，看到有要求快排非递归，就试着重写了一下，统计了下时间，大概完成花费 3 分钟 13.54 秒，相比直接使用编译器提供的栈，还是要慢一些。代码#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;using pii = pair&l...", "content": "很久没看过算法内容，今天逛了逛牛客，看到有要求快排非递归，就试着重写了一下，统计了下时间，大概完成花费 3 分钟 13.54 秒，相比直接使用编译器提供的栈，还是要慢一些。代码#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;using pii = pair&lt;int,int&gt;;const int N = 100010;void quick_sort(int arr[], int l, int r){ if(l &gt;= r) return; int i = l - 1, j = r + 1, x = arr[l + r &gt;&gt; 1]; while(i &lt; j){ while(arr[++i] &lt; x); while(arr[--j] &gt; x); if(i &lt; j) swap(arr[i], arr[j]); } quick_sort(arr, l, j); quick_sort(arr, j + 1, r);}void quick_sort(int arr[], int l, int r){ if(l &gt;= r) return; queue&lt;pii&gt; st; st.push({l, r}); while(st.size()){ auto [l, r] = st.front(); st.pop(); if(l &gt;= r) continue; int i = l - 1, j = r + 1, x = arr[l + r &gt;&gt; 1]; while(i &lt; j){ while(arr[++i] &lt; x); while(arr[--j] &gt; x); if(i &lt; j) swap(arr[i], arr[j]); } st.push({l, j}); st.push({j + 1, r}); }}int main(){ int n; cin &gt;&gt; n; int arr[N]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i]; quick_sort(arr, 0, n - 1); for(int i = 0; i &lt; n; i++) cout &lt;&lt;arr[i] &lt;&lt;' '; cout &lt;&lt; '\\n'; return 0;}" }, { "title": "数位DP", "url": "/posts/%E6%95%B0%E4%BD%8DDP/", "categories": "算法, 动态规划", "tags": "算法, 数位dp", "date": "2024-08-05 13:50:00 +0800", "snippet": "会用到的思想 前缀和 树结构对于范围内的数，N:\\[N = a_{n-1}a_{n-2}...a_0\\]也就是所有叶子结点的组合数的和。而计算组合数也可以通过递归得到：\\[C(a,b) = C(a - 1, b) + C(a - 1, b - 1)\\]通用代码实现以该题为模板修改即可：模板#include &lt;cstring&gt;#include &lt;iostream&gt;#...", "content": "会用到的思想 前缀和 树结构对于范围内的数，N:\\[N = a_{n-1}a_{n-2}...a_0\\]也就是所有叶子结点的组合数的和。而计算组合数也可以通过递归得到：\\[C(a,b) = C(a - 1, b) + C(a - 1, b - 1)\\]通用代码实现以该题为模板修改即可：模板#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 35;int K, B;// 如果碰到同类型的题，需要修改的内容：记忆化数组 f 以及原始实现范围内容// C(a, b)int f[N][N];void init(){ for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt;= i; j++){ if(!j) f[i][j] = 1; else f[i][j] = f[i - 1][j - 1] + f[i - 1][j]; } }}int dp(int n){ if(!n) return 0; vector&lt;int&gt; num; while(n) num.emplace_back(n % B), n /= B; int res = 0; int last = 0; for(int i = num.size() - 1; i &gt;= 0; i--){ int x = num[i]; // 原始实现 if(x){ // 左边分支 res += f[i][K - last]; if(x &gt; 1){ if( K - last - 1 &gt;= 0 )res += f[i][K - last - 1]; break; } else{ last++; if(last &gt; K) break; } } if(!i &amp;&amp; last == K) res++; // 原始实现 } return res;}int main(){ init(); int l, r; cin &gt;&gt; l &gt;&gt; r &gt;&gt; K &gt;&gt; B; cout &lt;&lt; dp(r) - dp(l - 1) &lt;&lt; '\\n'; return 0;}" }, { "title": "stl-optional 实现", "url": "/posts/stl-optional/", "categories": "C++, stl容器", "tags": "C++, stl容器", "date": "2024-08-02 17:13:00 +0800", "snippet": "最近使用 optional 容器，觉得其可以实现返回一个 T 类型或 nullopt 类型的操作挺有意思，这里参考一些内容重新复现该容器。// 重新封装 optional 类的异常class BadOptionalAccess : public std::exception {public: BadOptionalAccess() = default; virtual ~BadOptio...", "content": "最近使用 optional 容器，觉得其可以实现返回一个 T 类型或 nullopt 类型的操作挺有意思，这里参考一些内容重新复现该容器。// 重新封装 optional 类的异常class BadOptionalAccess : public std::exception {public: BadOptionalAccess() = default; virtual ~BadOptionalAccess() = default; const char *what() const noexcept override { return \"BadOptionalAccess\"; }};// 作为无内容时的返回struct nullopt_t { explicit nullopt_t() = default;};inline struct nullopt_t nullopt;/* 构造 Optional 大部分都是将外部需要存储的 T 类对象/变量 移动到内部 且构造过程中将移动进的变量进行 placement new 减少一次构造的成本，要记住这里 new 后需要手动析构 这里面需要注意的是 Optional 重载了乘号运算符，导致直接类内直接使用*可能是地址取值操作， 所以需要使用 std::addressof(·) 算子取地址 */template &lt;class T&gt; struct Optional {private: bool m_has_value; union { T m_value; };public: Optional() : m_has_value(false) {}; Optional(nullopt_t) noexcept : m_has_value(false) {}; Optional(T &amp;&amp;value) : m_has_value(true), m_value(std::move(value)) {}; Optional(Optional &amp;&amp;that) noexcept : m_has_value(that.has_value()) { if (m_has_value) { new (std::addressof(m_value)) T(std::move(that.m_value)); } } Optional(Optional const &amp;that) : m_has_value(that.has_value()) { if (m_has_value) { new (std::addressof(m_value)) T(that.value()); } } Optional &amp;operator=(nullopt_t) noexcept { if (m_has_value) { m_value.~T(); m_has_value = false; } return *this; } Optional &amp;operator=(T &amp;&amp;that) noexcept { if (m_has_value) { m_value.~T(); } new (std::addressof(m_value)) T(std::move(that)); m_has_value = true; return *this; } Optional &amp;operator=(Optional const &amp;that) { if (this == &amp;that) return *this; if (m_has_value) { m_value.~T(); m_has_value = false; } m_has_value = that.has_value(); m_value = that.value(); return *this; } Optional &amp;operator=(Optional &amp;&amp;that) noexcept { if (this == &amp;that) return *this; if (m_has_value) { m_value.~T(); m_has_value = false; } m_has_value = that.has_value(); if (m_has_value) { new (std::addressof(m_value)) T(std::move(that.value())); that.m_value.~T(); that.m_has_value = false; } return *this; } template &lt;class... Args&gt; requires(std::is_constructible_v&lt;T, Args...&gt;) void emplace(Args &amp;&amp;...args) { if (has_value()) { m_value.~T(); } new (std::addressof(m_value)) T(std::forward&lt;Args&gt;(args)...); m_has_value = true; } void reset() noexcept { if (m_has_value) { m_value.~T(); m_has_value = false; } } bool has_value() const noexcept { return m_has_value; } explicit operator bool(){ return has_value(); } T &amp;&amp;value() &amp;&amp; { if (!has_value()) [[unlikely]] throw BadOptionalAccess(); return std::move(m_value); } T const &amp;&amp;value() const &amp;&amp; { if (!has_value()) [[unlikely]] throw BadOptionalAccess(); return std::move(m_value); } T &amp;value() &amp; { if (!has_value()) [[unlikely]] throw BadOptionalAccess(); return m_value; } T const &amp;value() const &amp; { if (!has_value()) [[unlikely]] throw BadOptionalAccess(); return m_value; } T value_or(T default_value) const &amp; noexcept(std::is_copy_assignable_v&lt;T&gt;) { if (!has_value()) return default_value; return m_value; } T &amp;&amp; value_or(T default_value) &amp;&amp; noexcept(std::is_nothrow_move_assignable_v&lt;T&gt;) { if (!has_value()) return default_value; return std::move(value()); } T const &amp;operator*() const &amp; noexcept { return m_value; } T &amp;operator*() &amp; noexcept { return m_value; } T const &amp;&amp;operator*() const &amp;&amp; noexcept { return m_value; } T &amp;&amp;operator*() &amp;&amp; noexcept { return m_value; } T const *operator-&gt;() const noexcept { return std::addressof(m_value); } T *operator-&gt;() noexcept { return std::addressof(m_value); } ~Optional() noexcept { if (has_value()) m_value.~T(); }};" }, { "title": "更新Linux下的编译工具", "url": "/posts/%E6%9B%B4%E6%96%B0linux%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/", "categories": "Linux, 编译器", "tags": "Linux", "date": "2024-08-01 13:46:00 +0800", "snippet": "最近尝试使用一些比较新的语言特性 (C++23)，检查了下自己Linux提供的编译工具，发现使用的是Ubuntu 22.04默认提供的版本 (g++ 11.4 编译工具, 以及 clangd 14 lsp工具), 不能支持 C++23/20 标准的一些特性，安装 clangd因为 apt 未提供新版本安装，所以这里在官网更新一下：wget https://apt.llvm.org/llvm....", "content": "最近尝试使用一些比较新的语言特性 (C++23)，检查了下自己Linux提供的编译工具，发现使用的是Ubuntu 22.04默认提供的版本 (g++ 11.4 编译工具, 以及 clangd 14 lsp工具), 不能支持 C++23/20 标准的一些特性，安装 clangd因为 apt 未提供新版本安装，所以这里在官网更新一下：wget https://apt.llvm.org/llvm.shchmod +x llvm.shsudo ./llvm.sh &lt;version number&gt;我这里安装的版本是 clang 19, 安装结束后 update-alternatives 更新一下默认的执行路径即可update-alternatives --install /usr/bin/clangd clangd /usr/bin/clangd-19 20检查一下版本：Ubuntu clangd version 19.1.0Features: linux+grpcPlatform: x86_64-pc-linux-gnu安装 g++编译工具不同版本对 C++ 标准支持情况：gcc release cpprefsudo apt install build-essentialsudo apt install libmpfr-dev libgmp3-dev libmpc-dev -ywget http://ftp.gnu.org/gnu/gcc/gcc-14.1.0/gcc-14.1.0.tar.gztar -xf gcc-14.1.0.tar.gzcd gcc-14.1.0./configure -v --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu --prefix=/usr/local/gcc-14.1.0 --enable-checking=release --enable-languages=c,c++ --disable-multilib --program-suffix=-14.1.0makesudo make install安装结束后更新一下默认执行路径sudo update-alternatives --install /usr/bin/gcc-14.1.0 gcc-14.1.0 /usr/local/gcc-14.1.0/bin/gcc-14.1.0 14sudo update-alternatives --install /usr/bin/g++-14.1.0 g++-14.1.0 /usr/local/gcc-14.1.0/bin/g++-14.1.0 14这样默认使用 gcc/g++ 就会是最新的版本:g++-14.1.0 --version# g++-14.1.0 (GCC) 14.1.0# Copyright © 2024 Free Software Foundation, Inc.# 本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；# 包括没有适销性和某一专用目的下的适用性担保。安装过程中出现的问题 如果安装结果出现 libstdc++ 版本过低的情况，说明 linux 自带的 c++标准库不兼容，这里可以配置链接器，增加安装的 gcc14 编译器提供的 libstdc++.sosudo vim /etc/ld.so.conf.d/x86_64-linux-gnu.conf并将路径 /usr/lib/gcc-14.1.0 添加到文件中即可。 出现 unicode.h 赋值操作error issue 链接因为 clangd 版本过新，我后面退回到 clangd18 的版本就可以了。" }, { "title": "网络编程", "url": "/posts/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/", "categories": "Linux, 调试", "tags": "Linux", "date": "2024-07-29 13:31:00 +0800", "snippet": "打印 errno使用 string.h 头文件中的 strerror() 函数打印 errno 错误信息，就不需要查找 errno 对应的错误描述了。#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fmt/format.h&gt;fmt::println(strerror(errno));使用 Linux 相关调用使...", "content": "打印 errno使用 string.h 头文件中的 strerror() 函数打印 errno 错误信息，就不需要查找 errno 对应的错误描述了。#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fmt/format.h&gt;fmt::println(strerror(errno));使用 Linux 相关调用使用 Linux 相关调用实现功能的时候，经常会苦恼于每次都要验证是否调用成功，例如：// Linux 网络#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;fmt/format.h&gt;int main(){ int result = getaddrinfo(\"127.0.0.1\", \"8080\", NULL); if( result == -1 ) { fmt::print(\"getaddrinfo error: {}\\n\", strerror(errno)); return -1; } // ... return 0;}可以简单封装一下打印错误函数：// 可以在输出的时候显示对应的调用函数#define CHECK_CALL(func, ...) check_error(#func, func(__VA_ARGS__))int check_error(char *msg, int res){ if( res == -1 ){ fmt::println(\"Error: {}: {} {}\", msg, errno, strerror(errno)); throw; } return res;}int main(){ check_error(\"getaddrinfo\", getaddrinfo(\"127.0.0.1\", \"8080\", NULL)); // 使用宏的版本 CHECK_CALL(getaddrinfo, \"127.0.0.1\", \"8080\", NULL); // ... return 0;}" }, { "title": "力扣常用代码", "url": "/posts/LeetCodeCheatcode/", "categories": "算法, LeetCode", "tags": "算法, LeetCode", "date": "2024-07-29 12:30:00 +0800", "snippet": "LeetCode 常用代码解绑老爷爷实现auto _ = [](){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); return true;}();打印数组时使用template&lt;typename T&gt;ostream &amp;operator&lt;&lt;(ostream &amp;os, vector&l...", "content": "LeetCode 常用代码解绑老爷爷实现auto _ = [](){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); return true;}();打印数组时使用template&lt;typename T&gt;ostream &amp;operator&lt;&lt;(ostream &amp;os, vector&lt;T&gt; const &amp;arr){ os &lt;&lt; '['; for(auto i = arr.begin(); i != arr.end(); i++){ os &lt;&lt; *i; if(i != arr.end() - 1) os &lt;&lt; \",\"; } os &lt;&lt; \"]\"; return os;}或者使用这个，可以打印所有可迭代对象：// #include &lt;iterator&gt; // std::begin std::end// #include &lt;type_traits&gt; // std::is_same_vnamespace details {using std::begin;using std::end;template &lt;typename T, typename = void&gt; struct is_iterable : std::false_type {};template &lt;typename T&gt;struct is_iterable&lt;T, std::void_t&lt; decltype(begin(std::declval&lt;T&gt;())), decltype(end(std::declval&lt;T&gt;()))&gt;&gt;: std::true_type {};template &lt;typename T&gt; constexpr bool is_iterable_v = is_iterable&lt;T&gt;::value;} // namespace detailstemplate &lt;typename Container&gt; requires(details::is_iterable_v&lt;Container&gt; &amp;&amp; !std::is_same_v&lt;Container, std::string&gt;)std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, Container const &amp;arr) { os &lt;&lt; '['; for (auto i = arr.begin(); i != arr.end(); i++) { os &lt;&lt; *i; if (i != arr.end() - 1) os &lt;&lt; \",\"; } os &lt;&lt; \"]\"; return os;}" }, { "title": "模板元编程基础", "url": "/posts/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/", "categories": "C++, 模板元编程", "tags": "C++", "date": "2024-07-24 14:16:00 +0800", "snippet": "定义 一种特化重载int add(int a, int b){ ... }double add(double a, double b) { ...}// 依次类推，这样重复工作量较大// 改为模板，这里支持所有的平凡类型template &lt;typename T&gt;T add(T a, T b) { ... }// 同样可以支持非平凡类型template &lt;class T&g...", "content": "定义 一种特化重载int add(int a, int b){ ... }double add(double a, double b) { ...}// 依次类推，这样重复工作量较大// 改为模板，这里支持所有的平凡类型template &lt;typename T&gt;T add(T a, T b) { ... }// 同样可以支持非平凡类型template &lt;class T&gt;T add(T a, T b) { ... }// 拷贝昂贵则使用引用T add(cosnt T&amp; a, const T&amp; b) { ...} 额外参数引入方法void show_times(T msg, int times){ for(int i = 0; i &lt; times; i++){ std::cout &lt;&lt; msg &lt;&lt; std::endl; }}template&lt;int N&gt;void show_times(T msg){ for(int i = 0; i &lt; N; i++) std::cout &lt;&lt; msg &lt;&lt; std::endl;}// 两者区别：模板类引入的参数在编译器确定，这样可被编译器优化，而函数引入的参数在运行时确定，不可被优化。// 这样也引出了模板的使用会带来额外的编译开销 延迟编译策略template&lt;typename T&gt;void do_something(T arg){ }// 编译器仅编译会使用到的实际类型实例do_something(1); // 编译器编译int版本do_something(1.0); // 编译器编译double版本 可以自动推导需要编译的类型// 例如打印数组template&lt;typename T&gt;std::ostream std::cout operator &lt;&lt;(std::vector&lt;T&gt; arr){ std::cout &lt;&lt; '['; for(int i = 0; i &lt; arr.size(); i++){ std::cout &lt;&lt; arr[i]; if(i != arr.size() - 1) std::cout &lt;&lt; \", \"; } std::cout &lt;&lt; ']'; return std::cout;}int main(){ std::vector&lt;int&gt; arr1 = {1, 2, 3}; using std::cout; std::cout &lt;&lt; arr1 &lt;&lt; std::endl; // 输出[1, 2, 3] return 0;}一些常见的用法去除Debug代码// 宏替换，就可以去掉 debug 代码，编译器会自动优化掉#ifndef NDEBUG#define log(x) std::cout &lt;&lt; x &lt;&lt; std::endl#else#define log(x) (x)#endif// 传入模板参数, 这里表示默认打印template &lt;bool debug = true, T&gt;void log(T &amp;const msg){ if constexpr (debug) std::cout &lt;&lt; msg &lt;&lt; std::endl;}// 这样在编译期，就可以自动判断是否需要打印日志，并优化掉无用的代码// 需要注意，传入的模板参数编译器就需要确定，否则编译不通过int main(){ constexpr bool debug = false; log&lt;debug&gt;(\"hello world\"); return 0;}如何判断模板函数实例化的次数利用局部静态变量懒加载的特性，就可以判断实例化出来重载函数数量。int main(){ auto func = [](auto a){ static int _ = ::printf(\"instanced\\n\"); std::print(\"{}\", a); }; func(1); func(2); func(1.2f); return 0;}" }, { "title": "树状数组和线段树", "url": "/posts/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/", "categories": "算法, 动态规划", "tags": "算法, 区间dp", "date": "2024-07-07 16:13:00 +0800", "snippet": "树状数组可以认为是高级 维护前缀区间关系 数据结构，当需要修改时间复杂度较低的时候，采用树状数组，否则采用前缀数组。 操作 树状数组 前缀数组 单点更新 O(logn) O(n) 区间查询 O(logn) O(1) 区间更新 ...", "content": "树状数组可以认为是高级 维护前缀区间关系 数据结构，当需要修改时间复杂度较低的时候，采用树状数组，否则采用前缀数组。 操作 树状数组 前缀数组 单点更新 O(logn) O(n) 区间查询 O(logn) O(1) 区间更新 O(logn) O(n) 树状数组关键实现：// tr[N] 数组下标从 1 开始// lowbit 操作，构建树状数组的关键int lowbit(int x){ return x &amp; -x;}// 修改节点x，从叶子结点修改到树根:for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;// 查询节点x，从树根查询到叶子结点:int res = 0;for(int i = x; i &gt; 0; i -= lowbit(i)) res += tr[i];// 查询修改效率都是 O(logn)using namespace std;const int N = 100010;// 树状数组使用数组即可int tr[N], s;// 初始化，一般不需要，我们只要遍历输入数组即可void build(cosnt vector&lt;int&gt;&amp; arr){ for(int i = 0; i &lt; n; i++) modify(i, arr[i]);}// 前 x 项修改void modify(int x, int c){ for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c; // 数组求和对应的树状数组，如果需要其他形式改这里 // 求 max tr[i] = max(tr[i], c); // 求 min tr[i] = min(tr[i], c);}int find(int x){ int res = 0; for(int i = x; i; i -= lowbit(i)) res += tr[i]; // 同理, res = max(res, tr[i]); // res = min(res, tr[i]); return res;}画一张图：数字表示下标，颜色块最右端表示维护这一段数据的下标，长度表示被维护的数据范围，可视化查询，以 15 为例：每次跳转下标用 lowbit 操作即，pos = pos - lowbit(pos)，所以时间复杂度是 O(logn)。对应代码中编写：int query(int x){ int res = 0; for(int i = x; i; i -= lowbit(i)) res += tr[i]; return res;}可视化修改，以 9 为例:对应代码：void modify(int x, int c){ for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += c;}每次跳转下标用 lowbit 操作即，pos = pos + lowbit(pos)，所以时间复杂度是 O(logn)。线段树可以认为是高级 维护区间关系 的数据结构，相比树状数组，该数据结构可以维护的区间范围更加灵活，当需要修改时间复杂度较低的时候，采用 线段树. 操作 线段树 朴素数组 单点更新 O(logn) O(n) 区间查询 O(logn) O(1) 区间更新 O(logn) O(n) // 下标从 1 开始const int N = 100010;int m, p;struct Node{ int l, r; int v;}tr[N * 4];// pushup 操作void pushup(int u){ tr[u].v = max(tr[u &lt;&lt; 1].v tr[u &lt;&lt; 1 | 1].v);}// build 操作void build(int u, int l, int r){ tr[u] = {l, r}; if(l == r) return; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build( u &lt;&lt; 1 | 1, mid + 1, r); // pushup(u);}int query(int u, int l, int r){ if(l &lt;= tr[u].l &amp;&amp; r &gt;= tr[u].r) return tr[u].v; int mid = tr[u].l + tr[u].r &gt;&gt; 1; int v = 0; if(l &lt;= mid) v = query(u &lt;&lt; 1, l, r); if(r &gt; mid) v = max(v, query(u &lt;&lt; 1 | 1, l, r)); return v;}// 单点修改void modify(int u, int x, int v){ if(tr[u].l == x &amp;&amp; tr[u].r == x) tr[u].v = v; else{ int mid = tr[u].l + tr[u].r &gt;&gt; 1; if(x &lt;= mid) modify(u &lt;&lt; 1, x , v); else modify(u &lt;&lt; 1 | 1, x, v); pushup(u); }}数据结构的形式和堆一致，注意线段树开的空间大小应为 4n , 具体解释参考其他资料。" }, { "title": "GTest单元测试", "url": "/posts/GTest%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/", "categories": "CMake", "tags": "GTest, CMake", "date": "2024-07-05 15:13:00 +0800", "snippet": "使用GoogleTest常用的方法： 从源码中构建 Googletest 并加入 /usr/local, 这样后续所有本机用户都可以直接使用GTest: 直接将 GoogleTest 嵌入到自己的项目中，并编写相关代码进行适配准备工作从源码中构建不知道如何使用CMake 构建可以参考：CMake如何安装项目我们需要拿到 Googletest 源码，然后使用CMake进行编译，最后将其安装...", "content": "使用GoogleTest常用的方法： 从源码中构建 Googletest 并加入 /usr/local, 这样后续所有本机用户都可以直接使用GTest: 直接将 GoogleTest 嵌入到自己的项目中，并编写相关代码进行适配准备工作从源码中构建不知道如何使用CMake 构建可以参考：CMake如何安装项目我们需要拿到 Googletest 源码，然后使用CMake进行编译，最后将其安装到默认或我们自己指定的位置。然后在我们的项目中就可以通过 find_package() 指令来找到 Googletest 了：远程获取使用 CMake 中的 ContentFetch()，不需要手动获取项目并构建，即可自行从远程获取并执行对应的构建编译，具体:cmake_minimum_required(VERSION 3.14)project(my_project)# GoogleTest requires at least C++14set(CMAKE_CXX_STANDARD 14)set(CMAKE_CXX_STANDARD_REQUIRED ON)# FetchContent 要求 CMake 版本不低于 3.14include(FetchContent)FetchContent_Declare( googletest URL https://github.com/google/googletest/archive/03597a01ee50ed33e9dfd640b249b4be3799d395.zip)# For Windows: Prevent overriding the parent project's compiler/linker settingsset(gtest_force_shared_crt ON CACHE BOOL \"\" FORCE)FetchContent_MakeAvailable(googletest)在项目中使用 GTest# 顶层 CMakeLists.txtcmake_minimum_required(VERSION 3.10)project(myproject)# GoogleTest requires at least C++14set(CMAKE_CXX_STANDARD 14)set(CMAKE_CXX_STANDARD_REQUIRED ON)enable_testing()# 添加测试源文件目录add_subdirectory(${CMAKE_SOURCE_DIR}/test)# test/CMakeLists.txt# 从 CMake Modules 中搜索我们已经安装好的 Googletestfind_package(GTest REQUIRED)# 后面就可以使用 GTest 进行我们自己设定的单元测试add_executable(hello_test hello_test.cc)target_link_libraries(hello_test GTest::gtest_main)add_executable(yet_another_test yet_another_test.cc)target_link_libraries(yet_another_test GTest::gtest_main)find_package(GTest REQUIRED)add_executable(hello_test hello_test.cc)target_link_libraries(hello_test GTest::gtest_main)add_executable(yet_another_test yet_another_test.cc)target_link_libraries(yet_another_test GTest::gtest_main)# 两种加入 test 的方式# 使用 CMake 的 add_test() 命令add_test(NAME \"SimpleTest\" COMMAND hello_test)add_test(NAME \"SimpleTest2\" COMMAND yet_another_test)# 使用 GoogleTest 的 gtest_discover_tests() 命令include(GoogleTest)gtest_discover_tests(hello_test)gtest_discover_tests(yet_another_test)链接 GTest::GTest_main , 该库提供主函数，我们自己不需要额外定义。// test/hello_test.cc#include &lt;gtest/gtest.h&gt;// Demonstrate some basic assertions.TEST(HelloTest, BasicAssertions) { // Expect two strings not to be equal. EXPECT_STRNE(\"hello\", \"world\"); // Expect equality. EXPECT_EQ(7 * 6, 42);}TEST(HelloTest, AnotherBasicAssertions) { EXPECT_NE(0, 1);}// test/yet_another_test.cc#include &lt;gtest/gtest.h&gt;// Demonstrate some basic assertions.TEST(YetAnotherTest, SomeBasicAssertions) { // Expect two integers to be equal. EXPECT_EQ(2, 2); // Expect a string to contain a substring. EXPECT_STRCASEEQ(\"world\", \"WORld\"); // Expect a floating-point value to be within a certain range. EXPECT_NEAR(3.14159, 3.141, 0.001);}// 因为链接到的是 GTest::GTest_main, 所以不需要 main 函数项目结构：.├── CMakeLists.txt└── test ├── CMakeLists.txt ├── hello_test.cc └── yet_another_test.cc尝试构建项目并进行测试：&gt; mkdir build &amp;&amp; cd build&gt; cmake ..&gt; make &gt; make test结果：Running tests...Test project /home/momo/fun_stuff/learning/googletest/build Start 1: HelloTest.BasicAssertions1/5 Test #1: HelloTest.BasicAssertions ............ Passed 0.00 sec Start 2: HelloTest.AnotherBasicAssertions2/5 Test #2: HelloTest.AnotherBasicAssertions ..... Passed 0.00 sec Start 3: YetAnotherTest.SomeBasicAssertions3/5 Test #3: YetAnotherTest.SomeBasicAssertions ... Passed 0.00 sec Start 4: SimpleTest4/5 Test #4: SimpleTest ........................... Passed 0.00 sec Start 5: SimpleTest25/5 Test #5: SimpleTest2 .......................... Passed 0.00 sec100% tests passed, 0 tests failed out of 5Total Test time (real) = 0.02 sec使用两种方式都可正常执行单元测试，但使用 gtest_discover_tests() 命令给出的结果更细致，具体到每一个 TEST() 项.结果日志也都在 build/Testing/Temporary/LastTest.log 文件中，可以查看详细的测试结果。使用 GMock 提前使用未实现类使用方法：定义需要Mock的类，并给出所有接口函数，同时接口函数需要 virtual 修饰，这样就可以调用运行时 Mock 实现的函数。// gmock 与 gtest 都集成在 GoogleTest 库中#include &lt;gmock/gmock.h&gt;/*假设我们要 Mock 的类所有接口如下所示class Turtle { ... virtual ~Turtle() {}; virtual void PenUp() = 0; virtual void PenDown() = 0; virtual void Forward(int distance) = 0; virtual void Turn(int degrees) = 0; virtual void GoTo(int x, int y) = 0; virtual int GetX() const = 0; virtual int GetY() const = 0;};该接口来自GMock官方文档*/class MockTurtle: public(Turtle){public:\t// 所有需要 Mock 的方法都按照宏定义继承\t// MOCK_METHOD(return_type, method_name, (params_list), (suffix))\t// 四个参数分别对应，原方法/函数的：返回类型，名称，参数列表，函数后缀关键字\t...\tMOCK_METHOD(void, PenUp, (), (override); // 可以不加 override, 但是加上可以保证我们是在对该方法override，以防同名不同参数的函数被错误重载\tMOCK_METHOD(void, PenDown, (), (override));\tMOCK_METHOD(void, Forward, (int distance), (override));\t...\tMOCK_METHOD(int, GetY, (), (const, override));\t...};// 这样就可以定义一个 Mock 类// 测试中使用TEST(PainterTest, CanDrawSomething){\tMockTurtle turtle;\t// 具体期望 Mock 类调用时的返回什么的定义\t// 同时也给出了该调用当前测试期望调用几次，返回什么\tEXPECT_CALL(turtle, PenDown())\t\t.Times(AtLeast(1))\tEXPECT_CALL(turtle, GetX()) .Times(5) .WillOnce(Return(100)) .WillOnce(Return(150)) .WillRepeatedly(Return(200));\tPainter painter(&amp;turtle);\t\tEXPECT_TRUE(painter.DrawCircle(0, 0, 10));}参考链接 GoogleTest Primer" }, { "title": "CMake 使用记录", "url": "/posts/cmake%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/", "categories": "CMake", "tags": "CMake", "date": "2024-07-05 12:38:00 +0800", "snippet": "使用 CMake 构建项目的安装&gt; mkdir build &amp;&amp; cd build&gt; cmake ..&gt; make构建编译成功后，相关的库文件和头文件会生成在 build 目录下，如果该项目提供了安装的选项，则可以继续后面的内容。可以在顶层 CMakeLists.txt 中 include(GNUInstallDirs) 即表明作者对该项目提供了安装的选项。...", "content": "使用 CMake 构建项目的安装&gt; mkdir build &amp;&amp; cd build&gt; cmake ..&gt; make构建编译成功后，相关的库文件和头文件会生成在 build 目录下，如果该项目提供了安装的选项，则可以继续后面的内容。可以在顶层 CMakeLists.txt 中 include(GNUInstallDirs) 即表明作者对该项目提供了安装的选项。安装项目到指定目录如果需要将该项目所有的 include 和 lib 文件都安装到系统目录，则可以执行：sudo make install 该命令会将当前项目的头文件和库文件安装到默认 /usr/local/include 和 /usr/local/lib 目录或 /usr/include 和 /usr/lib 目录。如果需要该项目的库集成至任意指定目录中，即包括： include 目录：存放头文件 lib 目录：存放库文件 bin 目录：存放可执行文件(一般没有，我们只需要关注 include 和 lib 目录即可)需要使用 cmake 构建 build 目录过程中指定 install 目录：# 当前已经处于 build 目录cmake -DCMAKE_INSTALL_PREFIX=/path/to/install/dir ..这样，后面再执行 make install 命令会将头文件和库文件安装到指定的目录。如何确认是否已经设置好对应的目录？检查 build 目录下 cmake_install.cmake 文件，可以看到：if(NOT DEFINED CMAKE_INSTALL_PREFIX) set(CMAKE_INSTALL_PREFIX \"/path/to/install/dir\")endif()string(REGEX REPLACE \"/$\" \"\" CMAKE_INSTALL_PREFIX \"${CMAKE_INSTALL_PREFIX}\")set(CMAKE_INSTALL_PREFIX \"/path/to/install/dir\") 一致则表示设置成功。如何卸载已经安装的项目首先检查 build 目录，可以看到 install_manifest.txt 文件，里面记录了安装时的所有文件列表，我们可以直接根据该文件删除所有已经安装的所有相关文件：&gt; cat install_manifest.txt | xargs rm -rf" }, { "title": "C++ 内存管理", "url": "/posts/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/", "categories": "C++", "tags": "内存管理, C++", "date": "2024-07-01 13:34:00 +0800", "snippet": "内存管理之前对内存管理仅限于 C 的一套，即：在操作系统程序段式内存管理分为中堆段、栈段、bss段、data段、text段。在 C 中按区分配内存：堆区、栈区、静态存储区、常量存储区，现在重新接触了一下 C++ 部分，相比起来近似，但有额外的区分点。C++ 中的内存管理在C++中，内存分成5个区，分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。这里和 C 不相同的地方： C 中堆用...", "content": "内存管理之前对内存管理仅限于 C 的一套，即：在操作系统程序段式内存管理分为中堆段、栈段、bss段、data段、text段。在 C 中按区分配内存：堆区、栈区、静态存储区、常量存储区，现在重新接触了一下 C++ 部分，相比起来近似，但有额外的区分点。C++ 中的内存管理在C++中，内存分成5个区，分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。这里和 C 不相同的地方： C 中堆用于动态的分配内存，并由用户程序自行维护，在 C++ 中堆与 C 一致，用于存放 malloc/free 动态分配的内存，而自由存储区则为 new/delete 维护的内存，需要注意的是：自由存储区 一词表示为一种概念而非具体的存储位置，表示可以由用户决定如何分配内存，默认情况下编译器会将 new/delete 运算符实现为对 malloc/free 的封装，也可以由用户自行重载 new/delete 运算符实现在其他存储下申请；堆则为用户使用 malloc/free 时使用系统调用 mmap 或 brk 申请的内存空间.实现安全地内存资源分配一般使用 new/delele 的目的为扩展 malloc/free 函数无法实现的与对象绑定的构造和析构操作，但使用 new/delete 也同样引入了 malloc/free 的问题，即需要自行管理内存的分配。为了同时采取 new/delete 的高扩展性和栈内存分配的稳定性，可以采用 RAII 的方式封装所有需要申请的资源。 如果不采用封装的形式分配资源，遇到异常情况时，则难以管理已经分配的内存；// 使用栈的内存分配，实现当离开当前代码块自动调用obj的析构函数int main(){ SomeClass obj(args); // Some exception happpens if (excep) { // handle exception exit(1); } // end of exception return 0;}// obj的析构函数没有被调用，导致内存泄漏int main() { SomeClass *obj = new SomeClass(args); // Some exception happpens if (excep) { // handle exception exit(1); } // end of exception delete obj; return 0;} 更复杂的情况下，如果类中有多个资源，应该为每个资源都按照 RAII 的方式申请； 如果需要使用 new 分配对象，则使用 auto_ptr 进行管理，将分配到的对象 传递存储 在 auto_ptr 中，或者使用 C++11 标准的 unique_ptr 和 std::move()使用 auto_ptr 管理资源现在auto_ptr已经被废弃，建议使用 unique_ptr 和 shared_ptr 管理资源。使用 unique_ptr 管理资源unique_ptr 是 C++11 引入的智能指针，可以自动管理堆区资源的生命周期，其优点是： 避免了内存泄漏，当对象超出作用域时，会自动调用析构函数释放资源； 可以通过 * 和 -&gt; 操作符访问指针指向的资源； 可以通过 swap() 交换两个 unique_ptr 指向的资源； 可以通过 reset() 重置 unique_ptr 指向的资源，可以将其置空，也可以将其指向新的资源；在C++14中，unique_ptr 被扩展为支持移动语义，可以实现资源的移动，而不用拷贝，提高效率，我们亦可以使用 make_unique() 来创建 unique_ptr 对象；使用 std::move() 将资源的所有权转移到另一个 unique_ptr 对象中。举个例子#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class A {public: int some_field; A(int a_field) : some_field(a_field) { std::cout &lt;&lt; \"A()\" &lt;&lt; std::endl; } ~A() { std::cout &lt;&lt; \"~A()\" &lt;&lt; std::endl; } void print_something() { std::cout &lt;&lt; \"something\" &lt;&lt; std::endl; } void print_field() { std::cout &lt;&lt; \"some_field = \" &lt;&lt; some_field &lt;&lt; std::endl; }};void test_unique_ptr1() { // 从堆中申请空间初始化 A 并将指针传入 unique_ptr std::unique_ptr&lt;A&gt; p1(new A(1)); std::unique_ptr&lt;A&gt; p2(std::move(p1)); p1.reset(nullptr); // 主动将 p1 置空，避免使用已经被 p2 接管的资源}void test_unique_ptr() { // 从堆中申请空间初始化 A 并将指针传入 unique_ptr std::unique_ptr&lt;A&gt; p1(new A(1)); // 移动资源所有权，之后 p1 虽然仍指向原来的资源， // 但其指向的资源已经被 p2 接管，自身也不能继续使用 std::unique_ptr&lt;A&gt; p2(std::move(p1)); // 尝试使用已经被 p2 接管的资源，结果是不确定的 // bad things will happen p1-&gt;print_something(); // 输出 \"something\" p1-&gt;print_field(); // Segmentation fault p2-&gt;print_something(); // 输出 \"something\" p2-&gt;print_field(); // 输出 \"some_field = 1\" p1.reset(new A(2)); // p1 重新指向新的资源 p2-&gt;print_something(); // 输出 \"something\" p2-&gt;print_field(); // 输出 \"some_field = 1\" p1-&gt;print_something(); // 输出 \"something\" p1-&gt;print_field(); // Segmentation fault}int main() { test_unique_ptr(); test_unique_ptr1(); return 0;}使用 shared_ptr 管理资源shared_ptr 与 unique_ptr 类似，但可以多个 shared_ptr 指向同一资源，当最后一个 shared_ptr 被销毁时，资源才会被释放。shared_ptr 与 unique_ptr 的区别在于： 同一个资源可被多个 shared_ptr 指针指向，而 unique_ptr 指向的资源只能有一个； shared_ptr 可以通过 use_count() 方法获取引用计数，来判断资源是否被多个指针共享； shared_ptr 可以通过取指针 get() 和 * 操作符方式访问资源，修改引用计数；与unique_ptr相比，shared_ptr的优缺点： 与 unique_ptr 相比，shared_ptr 管理的资源可以被多个指针共享，因此可以减少内存的使用，提高效率； 与 unique_ptr 相比，shared_ptr 管理的资源的生命周期可以延长，因此可以避免资源泄漏； shared_ptr 管理的资源的生命周期与引用计数有关，因此需要注意引用计数的正确性； shared_ptr 可能会出现循环引用的情况，导致无法正常释放资源； shared_ptr 需要额外维护引用计数，相比 unique_ptr 更重，因此性能上会有一定的损失。避免出现循环引用的办法：使用 weak_ptr 代替 shared_ptr，同时使用 lock() 方法返回 shared_ptr，如果 shared_ptr 已经被销毁，则返回 nullptr，可以检查是否存在有效的 shared_ptr 指向资源，防止访问悬挂指针。检查程序是否发生常见的非法内存访问编译源代码时加入 -fsanitize=address 则检测到对应的非法内存访问，同时加入 -g 加入调试信息，这样出现对应的错误结果可以查看人类可以判断的信息 (行号等).参考 C++内存管理 内存泄漏检测工具" }, { "title": "多进程编程", "url": "/posts/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/", "categories": "Linux", "tags": "Linux", "date": "2024-06-26 23:01:00 +0800", "snippet": "多进程父子进程实现多进程的最简单方式为使用 fork() 系统调用：#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork();/* 成功则创建子进程 返回： 子进程返回 0 父进程返回子进程 pid; 失败则返回 -1，并设置 errno*/最终得到相同代码的两个进程，与 ...", "content": "多进程父子进程实现多进程的最简单方式为使用 fork() 系统调用：#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork();/* 成功则创建子进程 返回： 子进程返回 0 父进程返回子进程 pid; 失败则返回 -1，并设置 errno*/最终得到相同代码的两个进程，与 fork() 表意相同，即从当前位置 分叉(子进程继承了父进程的 PC 计数器值)。父子进程异同以及影响相同：父进程与子进程堆指针，栈指针和标志寄存器的值相同，文件描述符表；不同：子进程的 ppid 变为父进程 pid, 信号位图被清除，sighandler 不再对子进程生效。影响：父进程打开的文件描述符，用户工作目录和当前目录的引用计数 +1; 当父进程或子进程对数据有写操作，则会触发内核的写时复制，为子进程分配内存空间并复制父进程的数据。运行不同的程序使用条件判断当前进程是否父(子)进程，执行不同代码// 无关代码pid_t pid;if(pid = fork() &lt; -1){ // 创建失败 exit();}else if(pid == 0){ // 父进程 ...}else{ // 子进程 ...}系统调用 exec() 系列替换当前进程映像 什么是进程映像？1 进程所需的可执行文件，该文件包括代码段、数据段、堆和栈段。#include &lt;unistd.h&gt;extern char **environint execl(const char *pathname, const char *arg, ...);int execlp(const char *file, const char *arg, ...);int execle(const char *pathname, const char *arg, ...);int execv(const char *pathname, char *const argv[]);int execvp(const char *file, char *const argv[]);int execvpe(const char *file, char *const argv[], char *const envp[])/* exec*() 系统调用主要作用在于，根据用户提供的 pathname 或 file 加载程序 总的来说该系统调用有四种情况，l,p,e,v, 用户根据下标来自行判断使用： l-执行的程序参数按照可变参数传入，同时参数列表需要以 NULL 结尾； v-执行的程序参数按照 argv 字符串列表传入，argv 最后一个参数需为 NULL e-传入的参数中带有全局环境变量 envp 与 argv相同，都是字符串列表，同时结尾也需要 NULL p-表明所执行的文件在 $PATH 目录下寻找*/运行相同程序 父进程通过之间创建子进程，即可两个进程执行相同的程序 有时为了降低创建和销毁进程的开销，我们需要运行多个相同的进程竞争地提供服务，以空间换效率，这里可以采用 进程池 子进程的回收对于多进程来说，父进程需要跟踪子进程的退出状态。当子进程结束运行时，内核不会释放该进程进程表表项，而是等待父进程处理子进程退出时接收到的 SIG_CHLD 信号, 此时子进程已经结束，并等待(父进程/init进程)回收的状态即为 僵尸态；若父进程在子进程结束前就已经结束，那么子进程会交给 init 进程接管，此时子进程也为 僵尸态。父进程可以使用系统调用获取子进程的返回信息：#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;pid_t wait(int* stat_loc);pid_t waitpid(pid_t pid, int* stat_loc, int options);/* 其中 wait(&amp;stat_loc) 等价于 waitpid(-1, &amp;stat_loc, 0); 对于 waitpid: pid: &lt; -1 为等待所有相同 -pid gpid 的子进程 = -1 任何子进程 = 0 相同 gpid 下的子进程 &gt; 0 指定 pid 的子进程 stat_loc: 为 linux 专属，用于记录子进程如何退出，使用宏 (在&lt;sys/wait.h&gt;中) 可以判断 stat_loc 是哪一种类型，这里可以参考 man wait options: 决定系统调用的执行逻辑 WNOHANG 如果没有子进程退出就直接返回，即非阻塞等待 WUNTRACES 如果有子进程处于 stopped 状态，则不等待直接返回 WCONTINUED 如果子进程接收到信号 SIGCONT 并继续执行，则不等待直接返回 返回: 成功返回结束的子进程 pid 失败返回 -1, 同时设置 errno*/通常 waitpid 主要以非阻塞的形式使用，可以提高父进程的执行效率，防止父进程阻塞在等待子进程过程中int stat;// 根据 ret 判断是否正常结束，非阻塞调用int ret = waitpid(-1, &amp;stat, WNOHANG);多进程通信多进程之间通信可以使用管道 pipe() 进行单向通信。管道使用 pipe() 创建一个匿名管道，该系统调用返回一对 fd 分别表示可用于读和写描述符。参考 LinuxSocket使用场景 父子进程之间进行通信该方法最为简单，利用fork() 系统调用创建的子进程可以与父进程共享所有 fork() 之前的所有变量，变相实现了父子进程之间的文件描述符传递，然后可以分别关闭父子进程之间不需要使用的文件描述符部分即可。// 一般用于父子进程之间发送数据#include &lt;iostream&gt;#include &lt;unistd.h&gt;#include &lt;sys/types&gt;int main(){ int pfd[2]; // pfd[0] 用于读； pdf[1] 用于写 int pid; if(pipe(pfd)){ // 返回 0 时出错 exit(1); } pid = fork(); if(pid == -1){ // 出错 exit(1) } else if(pid != 0){ // 父进程 if(close(pfd[0])) exit(1); // 父进程向子进程写内容 } else{ // 子进程 if(close(pfd[1])) exit(1); // 子进程从pfd[0] 中读内容 }} 无关进程之间进行通信 父子进程共享文件描述符，也即父进程创建子进程，子进程重新加载进程映像 (execv())两进程间仍共享文件描述符的，但需要注意，子进程调用 execv() 过程中，需要传参对应文件描述符，因为 execv() 后虽然文件描述符表不变，但保存文件描述符的变量在加载进程映像过程中丢失了，所以需要通过传参该变量内容。 采用进程间通信 (IPC) 的方式进行通信Linux提供了两种标准对应实现进行通信: SRV4, POSIX. 这两种标准下都有对应的信号量，共享内存以及消息队列的实现。 SVR4 标准下的IPC系统调用多进程之间通信使用来自 SVR4 的三组系统调用，分别为有名信号量，共享内存以及消息队列。该系统调用实现较早，对老系统兼容性较强，如果需要实现最大兼容性，建议使用 SVR4 的 IPC 接口。信号量semget() 创建一个新的或获取一个已有的信号量集semop() 按照sembuf数组，对信号量集进行修改操作semctl() 直接控制信号量集中的信号量创建的信号量是全局唯一的，同时进程之间都可见。#include &lt;sys/sem.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/types.h&gt;// -------------------semget()----------------------------struct ipc_perm{ key_t key; uid_t uid; gid_t gid; uid_t cuid; gid_t cgid; mode_t mode;}struct semid_ds{ struct ipc_perm sem_perm; unsigned long int sem_nsems; time_t sem_otime; // 最后一次调用semop时间 time_t sem_ctime; // 最后一次调用semctl时间}int semget(key_t key, int num_sems, int sem_flags);/* key：全局唯一键值，对应一个信号量集，该键值获得方法： 通过文件路径字符串使用 ftok() 获取，或者使用 IPC_CREAT num_sems：信号量集中信号量的数量，创建时需要&gt;0，获取时不做要求 sem_flags：标志位，按位指定对应的设置 IPC_CREAT 创建新信号量集，如果已经存在不报错 IPC_CREAT | IPC_EXCL 保证创建新的信号量集，如果已经存在则返回 -1 errno置 EEXIST return: 成功返回 信号量集合 id 失败返回 -1 并设置 errno*/// -------------------semop()----------------------------struct sembuf{ unsigned short int sem_num;\t/* 信号量编号 */ short int sem_op;\t\t/* 信号量操作, &gt;0 加, &lt;0 减, 0 等待信号量为0*/ short int sem_flg;\t\t/* 信号量操作标志 IPC_NOWAIT(非阻塞) SEM_UNDO()*/};int semop(int semid, struct sembuf* sem_ops, size_t num_sem_ops);/* ... sem_ops：信号量操作 sembuf 数组 num_sem_ops: 数组尺寸 该系统调用给出了 num_sem_ops 项处理， 对信号量集中多个信号量进行操作，每项操作结构体为 sembuf*/// -------------------semctl()----------------------------// 该联合体需要自行提前定义，用来存放 semctl 给出的结果union semun { int val; /* 信号量集 */ struct semid_ds *buf; /* 留给 IPC_STAT, IPC_SET 的 buffer*/ unsigned short *array; /* 数组，使用 GETALL, SETALL 命令获得*/ struct seminfo *__buf; /* 信号量信息，使用 IPC_INFO 命令获得(Linux 特有) */};// 其中semid_ds 在 &lt;sys/sem.h&gt; 中有定义struct semid_ds { struct ipc_perm sem_perm; /* 当前信号的操作权限 */ time_t sem_otime; /* 使用 semop 的时间*/ time_t sem_ctime; /* 使用 semctl 的时间 */ unsigned long sem_nsems; /* 信号集中信号数量 */ };// 其中 ipc_perm 表示信号权限struct ipc_perm { key_t __key; /* 提供给 semget(2) 的键值 */ uid_t uid; /* Effective UID of owner */ gid_t gid; /* Effective GID of owner */ uid_t cuid; /* Effective UID of creator */ gid_t cgid; /* Effective GID of creator */ unsigned short mode; /* Permissions: 和chmod 中设置的权限一致，除可执行权限位无效 */ unsigned short __seq; /* Sequence number */};// 这一部分不需要我们进行操作，知道有什么就行，后面可以通过 semctl 获取struct seminfo { int semmap; /* Number of entries in semaphore map; unused within kernel */ int semmni; /* Maximum number of semaphore sets */ int semmns; /* Maximum number of semaphores in all semaphore sets */ int semmnu; /* System-wide maximum number of undo structures; unused within kernel */ int semmsl; /* Maximum number of semaphores in a set */ int semopm; /* Maximum number of operations for semop(2) */ int semume; /* Maximum number of undo entries per process; unused within kernel */ int semusz; /* Size of struct sem_undo */ int semvmx; /* Maximum semaphore value */ int semaem; /* Max. value that can be recorded for semaphore adjustment (SEM_UNDO) */};int semctl(int semid, int semnum, int cmd, ...);/* 与semop不同，该调用直接修改指定 semid 下 semnum 的信号量值, 第4个参数取决于 command, 对应的该参数 sys/sem.h 中提供了推荐格式 semun以及seminfo*/后面的接口都类似，所以仅给出对应的应用场景 (如果碰到) ，具体 API 实现按照 linux 下 manual 为主，全部留空。共享内存消息队列POSIX标准实现的IPC与 SVR4 类似，POSIX同样采用近似接口实现三种 IPC 方式。信号量共享内存消息队列多进程之间传递文件描述符不同进程之间如果要传递文件描述符，就需要将文件描述符对应的文件表项提取后，作为消息传递，该过程由内核自动完成，且需要使用 sendmsg 和 recvmsg 实现，并且使用辅助数据传送，即 msghdr 中的 msg_control 数据部分保存当前进程中要传递的文件描述符，并设置 cmsghdr.cmsg_type 为 SCM_RIGHTS 表示传递该文件描述符对应的表项的使用权。void send(int fd, int fd_to_send){ iovec iov[1]; struct msghdr msg; char buf[0]; // iov 中作为接收方保存的内存块 iov[0].iov_base = buf; iov[0].iov_len = 1; msg.msg_name = NULL; msg.msg_namelen = 0; msg.msg_iov = iov; msg.msg_iovlen = 1; cmsghdr cm; cm.cmsg_len = CONTROL_LEN; cm.cmsg_level = SOL_SOCKET; // SMC_RIGHTS 表明当前发送的是文件描述符使用权，即对应的文件项 cm.cmsg_type = SCM_RIGHTS; *(int *)CMSG_DATA(&amp;cm) = fd_to_send; msg.msg_control = &amp;cm; msg.msg_controllen = CONTROL_LEN; sendmsg(fd, &amp;msg, 0);}杂项多进程调试 当调试多进程时，默认仅跟踪父进程，如果需要跟踪子进程，需要额外进行设置使用 gdb在gdb中设置：set detach-on-fork false并可以通过 show inferiors 检查当前多个进程的情况以及序号如果需要切换进程调试则调用 inferior 序号 来切换当前正在调试的进程使用 vscode 调试如果需要使用 vscode 进行多进程调试，限制会较多，通过设置调试选项选择fork后默认跟踪进程为子进程：\"setupCommands\": [ { \"description\": \"设置默认跟踪进程\", \"text\": \"-gdb-set follow-fork-mode child\", }或设置fork后不分离：\"setupCommands\": [ { \"description\": \"fork后分离其他进程\", \"text\": \"-gdb-set detach-on-fork off\", }参考 IPC - Process Image &#8617;&#xfe0e; " }, { "title": "状态压缩", "url": "/posts/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/", "categories": "算法, 动态规划", "tags": "算法, 动态规划", "date": "2024-06-26 21:31:00 +0800", "snippet": "2741. 特别的排列原始链接最初观察该题，并未从数据规模出发，仅通过观察题目，认为应该采用并查集+数学的方式计算，即每个并集为满足条件：对于 0 &lt;= i &lt; n - 1 的下标 i ，要么 nums[i] % nums[i+1] == 0 ，要么 nums[i+1] % nums[i] == 0.对应集合，但是最大的问题为，这样划分出来的集合并不是不重合的，那么在得到对应的并...", "content": "2741. 特别的排列原始链接最初观察该题，并未从数据规模出发，仅通过观察题目，认为应该采用并查集+数学的方式计算，即每个并集为满足条件：对于 0 &lt;= i &lt; n - 1 的下标 i ，要么 nums[i] % nums[i+1] == 0 ，要么 nums[i+1] % nums[i] == 0.对应集合，但是最大的问题为，这样划分出来的集合并不是不重合的，那么在得到对应的并查集后，难以通过数学的方式计算出结果。那么该问题应该需要用回溯搜索+剪枝的方法，该方法的搜索空间为数据列表的全排列，观察数据集规模为 2 &lt;= nums.length &lt;= 14 ，可以得出朴素搜索会导致 TLE.对于状态空间f(s,j), 即 s 表示已经占用数组，j 则表示已占用数组中最后选择数字的下标，对应状态转移方程为：\\[f(S,j) = \\sum f(S/i, i), \\qquad S = \\{当前已占用的元素\\}\\]同时数据集规模较小，所以可以对状态集合压缩，使用单个 int 即可表示其中一集合状态。class Solution {public: int specialPerm(vector&lt;int&gt;&amp; nums) { int n = nums.size(), u = (1 &lt;&lt; n) - 1; vector&lt;vector&lt;long long&gt; &gt; memo(u, vector&lt;long long&gt;(n, -1)); // memo[s][n] // s: 0 ~ (1 &lt;&lt; n) - 1; // n: 0 ~ n - 1; int mod = 1e9 + 7; // 状态压缩+记忆化搜索 function&lt;long long(int,int)&gt; dfs = [&amp;](int s, int j) -&gt; long long{ if(s == ((1 &lt;&lt; n) - 1)) return 1; long long&amp; res = memo[s][j]; if(res != -1) return res; res = 0; for(int i = 0; i &lt; n; i++){ // 选择未使用的下标搜索 if((s &gt;&gt; i &amp; 1) == 0 &amp;&amp; (nums[i] % nums[j] == 0 || nums[j] % nums[i] == 0)){ res = (res + dfs(s ^ (1 &lt;&lt; i), i)) % mod; } } return res; }; long long res = 0; for(int i = 0; i &lt; n; i++){ res = (res + dfs(1 &lt;&lt; i, i)) % mod; } return res; }};蒙德里安的梦想题目链接// f[i][j] 表示第i列中上一些伸出的方格, 用j的每一位进行存储// 状态转移：f[i - 1][k] 与 f[i][j] 的状态是否合法// j &amp; k == 0 &amp;&amp; check(j | k)// check(a) a中无连续奇数个0// 边界问题：f[0][new_state] : new_state满足 check 要求#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N = 12, M = 1 &lt;&lt; N;int n, m;long long f[N][M];bool st[M];// 检查状态 a 是否满足要求bool check(int a){ int cnt = 0; for(int i = 0; i &lt; n; i++){ if((a &gt;&gt; i) &amp; 1){ if(cnt &amp; 1) return false; cnt = 0; }else{ cnt++; } } if(cnt &amp; 1) return false; return true;}int main(){ while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m)){ memset(f, 0, sizeof f); // 初始化合法状态 // 枚举所有的状态 i，减少后续重复状态合法性 for(int i = 0; i &lt; 1 &lt;&lt; n; i++){ // 该状态是否合法符合 check 要求 if(check(i)) st[i] = true; else st[i] = false; } // cout &lt;&lt; st[0] &lt;&lt; st[1] &lt;&lt; endl; f[0][0] = 1; for(int i = 1; i &lt;= m; i++) for(int j = 0; j &lt; 1 &lt;&lt; n; j++) for(int k = 0; k &lt; 1 &lt;&lt; n; k++) if(((j &amp; k) == 0) &amp;&amp; (st[j | k])) f[i][j] += f[i - 1][k]; cout &lt;&lt; f[m][0] &lt;&lt; endl; } return 0;}" }, { "title": "二分搜索的两种模板", "url": "/posts/%E5%85%B3%E4%BA%8E%E4%BA%8C%E5%88%86%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/", "categories": "算法, 搜索", "tags": "算法", "date": "2024-06-20 14:51:00 +0800", "snippet": "第一种该二分采用的是 yxc 的二分搜索方法，搜索范围为 [lower_bound, upper_bound], 对应模板为：// 左闭int lower_bound(int arr[], int l, int r, int target){ while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(arr[mid] &...", "content": "第一种该二分采用的是 yxc 的二分搜索方法，搜索范围为 [lower_bound, upper_bound], 对应模板为：// 左闭int lower_bound(int arr[], int l, int r, int target){ while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(arr[mid] &gt;= target) r = mid; else l = mid + 1; } return l;}// 右闭int upper_bound(int arr[], int l, int r, int target){ while(l &lt; r){ int mid = l + r + 1 &gt;&gt; 1; if(arr[mid] &lt;= target) l = mid; else r = mid - 1; } return l;}该搜索方法倾向于找沿单独方向最远处的 target, 也就是左搜最左，右搜最右，同时左搜过程中 mid 下取整，右搜过程中 mid 上取整，保证该算法不会搜索到非法下标第二种该方法来自 算法珠玑, 搜索范围为 [lower_bound, uppper_bound), 对应模板为：// 左闭int lower_bound(int arr[], int l, int r, int target){ while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(arr[mid] &lt; target) l = mid + 1; else r = mid; } return l;}// 右开int upper_bound(int arr[], int l, int r, int target){ while(l &lt; r){ int mid = l + r &gt;&gt; 1; if(arr[mid] &lt;= target) l = mid + 1; else r = mid; } return l;}lower_bound 以及 upper_bound 区别仅在于判断边界处是否相等，即：arr[mid] &lt;= target，如果相等，则继续在右块中继续搜索，找对应 target 的右开边界" }, { "title": "Linux多线程", "url": "/posts/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/", "categories": "Linux", "tags": "Linux", "date": "2024-06-11 11:37:00 +0800", "snippet": "多线程 线程定义： 线程是程序中完成一个独立任务的完整执行序列，为一个可调度的实体。线程分为内核线程和用户线程，其中内核线程在内核空间，由内核调度；用户线程则由线程库调度。内核线程获得CPU使用权时则加载并运行一个用户线程，可以说内核线程为用户线程的容器线程有三种实现模式：完全在用户空间实现，完全由内核调度，双层调度机制。使用多线程的优势：避免线程等待IO降低CPU使用率需要注意的是，当...", "content": "多线程 线程定义： 线程是程序中完成一个独立任务的完整执行序列，为一个可调度的实体。线程分为内核线程和用户线程，其中内核线程在内核空间，由内核调度；用户线程则由线程库调度。内核线程获得CPU使用权时则加载并运行一个用户线程，可以说内核线程为用户线程的容器线程有三种实现模式：完全在用户空间实现，完全由内核调度，双层调度机制。使用多线程的优势：避免线程等待IO降低CPU使用率需要注意的是，当需要在项目中使用 pthread.h 库时，编译时需要链接 -pthread现有常用线程库当前Linux内核采用NPTL作为线程标准API的实现，采用完全内核调度的方式实现，内核线程和用户线程数量为 1:1线程库API创建线程创建线程使用 pthread_create，定义：#include &lt;pthread.h&gt;int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg);/* thread 表示线程标识符 attr 为线程的属性 start_routine 为线程要执行的函数指针 arg 为函数的参数*/线程结束线程执行结束时调用 pthread_exit，定义：#include &lt;pthread.h&gt;int pthread_exit(void* retval);/* retval 为线程向线程回收者发送的信息，不会返回到调用者*/回收线程任何线程都可以通过调用 pthread_join 来回收其他线程，定义：#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval);取消线程终止一个线程可以通过调用 pthread_cancel 实现，定义：#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread);多线程同步多线程同步指：2 到多个线程之间有竞争关系，其中一个线程拿到关键资源，其他线程必须等待该线程处理结束后，才能从中选出下一个拿到该关键资源，这里的 关键资源 可以指代：信号量，锁。POSIX信号量#include &lt;semaphore.h&gt;int sem_init(sem_t* sem, int pshared, unsigned int value);// pshared 变量为 0 时，仅在当前进程下的线程间共享，非 0 则在多个进程之间共享int sem_destroy(sem_t* sem);int sem_wait(sem_t* sem);int sem_trywait(sem_t* sem);// trywait为 wait 的非阻塞版本；相比 wait, 若不能立即减少信号量值，则返回错误 (errno: EAGAIN), 而不是阻塞int sem_timedwait(sem_t* sem, const struct timespec *abs_timeout);// 相比 wait, 该函数指定了当前线程最大阻塞时间 abs_timeout, 一旦超时该函数则立即返回超时错误 (errno: ETIMEOUT)int sem_post(sem_t* sem);上述函数成功皆返回 0, 失败则返回使用 semaphore.h 时和 phtread.h 相同，都需要在编译时使用 -pthread 进行链接。互斥锁 用于保护关键代码段，不被多个线程同时访问。 mutex MUTual EXclusion device互斥锁只有两种状态：解锁(不被任何线程拥有), 锁定(被一个线程拥有)。一个线程试图锁定已被锁定的互斥锁会被挂起，直到被拥有者解开#include &lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);// 初始化 mutex, 其中 mutexattr 传入 NULL 时为默认初始化，初始化为 fast mutexint pthread_mutex_destroy(pthread_mutex_t *mutex);int pthread_mutex_lock(pthread_mutex_t *mutex);int pthread_mutex_trylock(pthread_mutex_t *mutex);int pthread_mutex_unlock(pthread_mutex_t *mutex);使用时：// 假设要保护的变量为 xint x;pthread_mutex_lock(&amp;mutex);// 操作 xpthread_mutex_unlock(&amp;mutex);条件变量#include &lt;pthread.h&gt;int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);// 初始化 cond, 其中 cond_attr 传入 NULL 时为默认初始化int pthread_cond_destroy(pthread_cond_t *cond);int pthread_cond_signal(pthread_cond_t *cond);int pthread_cond_broadcast(pthread_cond_t *cond);int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);线程与进程当一个进程使用 fork() 创建子进程，子进程只拥有一个执行线程，该线程是调用 fork 线程的完整复制，父进程的互斥锁，条件变量以及信号量则继承到子进程中，这样就会导致子进程不确定当前的互斥锁，条件变量和信号量是加锁还是解锁状态，且这样的状态是否是其他线程造成的，例如mutex，如果mutex为其他线程已经加了锁，创建子进程后，就无法对该 mutex 执行任何操作，导致子进程的线程对该 mutex 加锁必然会出现死锁问题。针对这种情况，需要使用 thread.h 中的 pthread_atfork() 进行处理：#include &lt;pthread.h&gt;int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void))/* 该函数提供三个句柄用于清理进程中的互斥锁状态 1. 调用 fork() 创建子进程之前会执行 prepare 2. 调用 fork() 后返回结果前，在父进程调用 parent 3. 调用 fork() 后返回结果前，在子进程调用 child*/这样在创建子进程前，可以通过该函数清空进程中的互斥锁状态：void prefork(){ pthread_mutex_lock(&amp;mutex);}void infork(){ pthread_mutex_unlock(mutex);}// 父进程执行过程pthread_atfork(prefork, infork, infork);// 然后再开始进行 fork 操作int pid = fork();...// 后续操作这样就可以实现在创建子进程前，首先加锁获得运行状态，保证创建子进程的过程是当前线程持有锁，在创建子进程完成后，子进程与父进程都释放锁，这样的过程使得父进程中其他线程管理的锁状态在子进程中都被释放。" }, { "title": "IO复用", "url": "/posts/io%E5%A4%8D%E7%94%A8/", "categories": "Linux", "tags": "Linux", "date": "2024-06-10 22:34:00 +0800", "snippet": "IO复用使用场景： 客户端程序要同时处理多个 socket; 客户端程序要同时处理用户输入和网络连接； TCP服务器要同时处理监听和连接socket 某一个服务需要复用同一个端口进行服务三个系统调用用来实现IO复用：select(), poll(), epoll()selectselect() 允许程序监视多个文件描述符，直到一个或者多个文件描述符变为 准备就绪 状态， 准备就绪 表...", "content": "IO复用使用场景： 客户端程序要同时处理多个 socket; 客户端程序要同时处理用户输入和网络连接； TCP服务器要同时处理监听和连接socket 某一个服务需要复用同一个端口进行服务三个系统调用用来实现IO复用：select(), poll(), epoll()selectselect() 允许程序监视多个文件描述符，直到一个或者多个文件描述符变为 准备就绪 状态， 准备就绪 表示一个文件描述符可以执行对应的 IO 操作需要注意的，select() 监视文件描述符有上限，由 FD_SETSIZE 决定#include &lt;sys/select.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);/* select 可以监视三种文件描述符事件：读，写和异常， 如果不需要监视其中的一种或多种文件描述符，则可传入 NULL nfds：传入的文件描述符总数，这里需要传入的三类文件描述符中最大值加一； readfds：监视文件描述符是否处于可读的状态 writefds：监视文件描述符是否处于可写的状态 exceptfds：监视文件描述符是否处于异常的状态 timeout: 超时限制，如果传递 NULL 则该函数会一直阻塞指导有描述符就绪*/其中 fd_set 为如何添加对应的文件描述符进行监视：库中提供对应的宏可以实现对应的文件描述符集合进行监视设置： FD_ZERO(&amp;fd_set) 该宏清空所有的fd_set 中所有监视的文件描述符 FD_SET(fd, &amp;fd_set) 将fd添加到指定的fd_set FD_CLR(fd, &amp;fd_set) 将fd从指定的fd_set中剔除 FD_ISSET(fd, &amp;fd_set) 测试fd是否已经添加到fd_set中上述任何文件描述符在系统调用 select() 返回时，会自动清空除已就绪文件描述符以外的集合内容。#include &lt;sys/select.h&gt;#include &lt;iostream&gt;using namespace std;int main(){ fd_set rfds; struct timeval tv; tv.tv_sec = 5; tv.tv_usec = 0; FD_ZERO(&amp;rfds); FD_SET(0, &amp;rfds); retval = select(1, &amp;rfds, NULL, NULL, &amp;tv); if(resval == -1) perror(\"select()\"); else if(retval) // 如果要判断具体哪个fd，使用FD_ISSET(fd, &amp;rfds) // 这里由于之前我们监控 0，也即标准流fd是否有可读事件 cout &lt;&lt; \"Data is available now.\" &lt;&lt; endl; else cout &lt;&lt; \"No data\" &lt;&lt; endl; exit(EXIT_SUCCESS);}pollpoll 与 select 类似，执行逻辑相同，对应的接口：#include &lt;poll.h&gt;int poll(struct pollfd *fds, nfds_t nfds, int timeout);// fds为 nfds 个 poolfd结构数组，并在设定的 timeout 毫秒内进行监视，// 若timeout设置为 NULL，则在有文件描述符有就绪事件前，会一直阻塞其中 struct pollfd 结构如下：struct pollfd{ int fd; // 文件描述符 short events; // 请求的事件 short revents; //实际返回的事件}/* 其中事件可以 按照啊按位或的方式添加，包括： POLLIN, POLLOUT, POLLERR*/如何使用#include &lt;poll.h&gt;int size = N;struct pollfd pfds[size];int timeout = 1000;int ret = poll(pfds, size, timeout);// 虽然返回了ret，代表有多少就绪事件，但是该系统调用// 仍然需要用户手动遍历 pfds 判断具体哪个事件就绪for(int i = 0; i &lt; size; i++){ if(pfds[i].revents &amp; POLLIN){ // 该事件读就绪 int sockfd = fds[i].fd; // 处理该socket }}epollepoll 为 Linux 特有的IO复用函数，与 poll 类似，可以同时监控多个文件描述符是否可用。相比前面的两个系统调用，epoll的核心为 epoll 实例，为内核数据结构，该实例将事件分为事件表 (interest set) 和就绪表 (ready set)。其中事件表 (interest set) 为程序注册监控的文件描述符集合；就绪表 (ready set) 为内核控制自动生成的就绪文件描述符合集。如何使用 首先创建一个 epoll 实例，通过 epoll_create 创建实例，并返回对应的文件描述符，我们可以通过该描述符间接控制 epoll 实例 使用 epoll_ctl 控制 epoll 实例中的兴趣列表 使用 epoll_wait 阻塞地等待是否有可用事件其中:int epoll_create(int size);// 该系统调用建立一个 epoll 实例，也就是内核事件表，// 该系统调用返回fd用来表示该实例，size 为事件表大小int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);/* op: 操作: EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别实现向时间表中注册，修改事件表以及从事件表中取消注册 fd: 操作描述符 event：要传入的事件 该系统调用将 fd 绑定事件 event, 在 epfd所在事件表进行 op 操作*/// 其中 epoll_event 结构为typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64;} epoll_data_t;struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */};/* events 可以放入多种事件，常用的有： EPOLLIN, EPOLLOUT, EPOLLRDHUP, EPOLLET, EPOLLONESHOT EPOLLIN: 读事件 EPOLLOUT: 写事件 EPOLLRDHUP: 流式socket对端关闭连接或者关闭写半连接 EPOLLET: 边缘触发模式*/int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);/* epoll 阻塞等待 epfd 中事件表中的时间是否有就绪事件， 有则在 timeout 时间内返回就绪事件数量， 同时将对应的就绪事件发送至 events 数组中； 否则继续阻塞*/level-triggered 与 edge-triggered 两种触发模式epoll 事件分发接口有两种模式：电平触发，边缘触发。触发模式存储在 epoll_event 结构体中，通过位操作设置。 TL;DR 电平触发保持通知未处理事件；边缘触发仅通知一次，且边缘触发需要使用非阻塞 fd样例场景： 一个读管道文件描述符 (rfd) 注册到 epoll 实例中 对端管道写 2KB 数据 调用 epoll_wait() 获得 rfd 就绪事件 从管道读 1KB 数据 再次调用 epoll_wait()对于电平触发，3 和 5 都会获得 rfd 就绪事件，而对于边缘触发，仅 3 可获得 rfd 就绪事件，而 5 不会得到期望的结果，即使剩余的数据仍保存在管道中。电平触发：事件就绪后，只要不消费完数据，那么该事件会保持触发边缘触发：事件就绪后，只要获得了对应的就绪事件，后续该事件不会继续触发 (除非对端重新提供了就绪条件，但不是当前期望的数据)使用 ET 触发模式所以如果要是用 ET触发模式，需要 将 socket 设置为非阻塞的 仅在 read() 或 write() 返回 EAGAIN 后才等待新的事件如果对端提供了多块数据流，而有多个线程从该管道中读取数据，仅使用上述方法不能有效解决，多块数据流区分的问题，这里调用者可以在事件中设置 EPOLLONESHOT 令 epoll 返回一次就绪事件后即禁用该描述符的关联。后面调用者需要自行修改事件表对该描述符的设置：void resetoneshot(int epfd, int fd){ epoll_event event; event.data = fd; event.events = EPOLLIN | EPOLLET | EPOLLONESHOT; epoll_ctl(epfd, EPOLL_MOD, fd, &amp;event);}三者之间比较epoll相比其他两个系统调用，提供了单独的服务用于注册对应的时间，同时使用回调的方式进行事件提醒，在事件多，而就绪事件较少的情况下效率较高，当就绪时间多的情况下，遍历和回调的效率逐渐接近。 系统调用 select poll epoll 用户索引就绪fd复杂度 O(n) O(n) O(1) 内核检查fd是否就绪复杂度 O(n) O(n) O(1) 如何判断事件是否就绪 轮询 轮询 回调 对当前线程是否阻塞 是 是 是 应用阻塞操作变为非阻塞操作例如 connect() 系统调用，如果 socket 设置为阻塞，那么连接过程中会发生阻塞让出CPU，直到连接成功或失败，可以通过 sockctl()设置 SOCK_NONBLOCK 标识到 socket 使其执行系统调用 connect() 变为非阻塞的，这样线程就不会因为阻塞让出CPU，自身可以在时间片范围内，继续处理其他事务，并使用 select() 监视该 socket 是否有对应的可就绪事件 (这里是 socket 写就绪), 如果有并且判断连接成功那么可以继续执行连接后的操作。但我们可以看到，该线程使用系统调用 connect() 就是为了获得结果后继续执行下面的任务，那么将阻塞操作变为非阻塞是无意义或意义不大的，不如主动放弃当前时间片，等待 connect() 返回结果；如果将 connect() 变为非阻塞的，那么该线程在执行下一系列关键操作(需要 connect() 结果)前，只能自旋地占用时间片，或者在这段时间片中做一些其他的工作，然后检查 connect() 是否结束 (如上一段所说的方法)。" }, { "title": "同步/异步 阻塞/非阻塞", "url": "/posts/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/", "categories": "Linux", "tags": "Linux", "date": "2024-06-10 22:01:00 +0800", "snippet": "看到一篇非常好的解释，这里记录一下stackoverflow链接TL;DR同步/异步 是描述 X 和 Y 之间的关系阻塞/非阻塞 描述 X 的状态如何解释 阻塞：Y 响应 X 前，X 需要一直等待 Y. 那么 X 就是阻塞的状态； 非阻塞：Y 响应 X 前，X 可以继续做其他事，至于 Y 执行完毕没有，X不知道，它可以定期来检查一下，或者等 Y 通知它完成，这不重要，重要的是 X 可以继...", "content": "看到一篇非常好的解释，这里记录一下stackoverflow链接TL;DR同步/异步 是描述 X 和 Y 之间的关系阻塞/非阻塞 描述 X 的状态如何解释 阻塞：Y 响应 X 前，X 需要一直等待 Y. 那么 X 就是阻塞的状态； 非阻塞：Y 响应 X 前，X 可以继续做其他事，至于 Y 执行完毕没有，X不知道，它可以定期来检查一下，或者等 Y 通知它完成，这不重要，重要的是 X 可以继续做他的自己的事情 同步：Y 响应 X 前，X 必须等待 Y 的结果才能继续执行下去，我们就可以说 X 和 Y 是同步的 异步：Y 响应 X 前，X 可以离开做其他事，直到 Y 通知它，我们称 X 和 Y 是异步的X 和 Y 是什么？可以是线程，可以是进程，也可以是其他的什么，这不重要。结论One more time: the four words serve for the design of architecture. So what we need is to make a proper architecture, instead of distinguishing the four words like a language lawyer. If you get some cases, where you can’t distinguish the four words very clearly, you should forget about the four words, use your own words to describe your architecture." }, { "title": "Linux系统日志", "url": "/posts/Linux%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97/", "categories": "Linux", "tags": "Linux", "date": "2024-06-06 16:17:00 +0800", "snippet": "Linux日志现有的Linux通常通过进程 syslogd 或 rsyslogd 进程提供日志服务，后者为前者的升级版。使用 rsyslogd 进程： 用户进程可以通过系统调用 syslog() 函数生成系统日志，该函数将日志输出到 AF_UNIX 类型socket文件，该文件位于 /dev/log, rsyslogd 则监听该文件，来获取用户的输出日志； 内核进程通过调用 printk...", "content": "Linux日志现有的Linux通常通过进程 syslogd 或 rsyslogd 进程提供日志服务，后者为前者的升级版。使用 rsyslogd 进程： 用户进程可以通过系统调用 syslog() 函数生成系统日志，该函数将日志输出到 AF_UNIX 类型socket文件，该文件位于 /dev/log, rsyslogd 则监听该文件，来获取用户的输出日志； 内核进程通过调用 printk() 将内核日志发送至内核环状缓存中，可以通过 dmesg 在终端打印内核日志，换装缓存内容则映射至 /proc/kmsg 中，rsyslogd 监听该文件来获取，内核的输出日志。rsyslog 将输入的日志按照分类分别放到不同的文件中，默认情况下：调试信息会放在 /var/log/debug 文件；普通消息会放在 /var/log/messages 文件；内核消息保存在 /var/log/kern.log 文件。如果需要修改 rsyslog 的配置，可在 /etc/rsyslog.conf 文件进行调整，具体可以设置： 内核日志的输入路径 是否监听tcp日志或udp日志，默认端口都为 514 子配置路径，默认为 /etc/rsyslog.d/*.conf日志信息在Linux系统日志中按照下述传递：使用 syslog 系统调用用户要使用系统日志，可以使用 syslog 系统调用实现，对应的定义为：#include &lt;syslog.h&gt;/** 使用系统日志首先需要打开系统日志连接，该函数有三个参数，按顺序的作用分别为： ident: 日志消息前的标志字符串，一般设置为程序的名称，传递 NULL 则会使用程序名 option: 设置调用 syslog() 的行为 facility: 默认的设施值，默认为 LOG_USER 可以不使用该函数，直接 syslog(), 那么会进行默认的 openlog() 连接**/void openlog(const char *ident, int option, int facility);// priority 设置当前日志信息的优先级，该优先级使由设施值和日志等级按位或得到。// format 与printf使用方法相同// eg. syslog(priority, \"%s\", string);void syslog(int priority, const char *format, ...);// 结束使用系统日志后需要关闭连接void closelog(void);" }, { "title": "即服务aSS", "url": "/posts/aaS/", "categories": "基础", "tags": "基础", "date": "2024-06-05 22:10:00 +0800", "snippet": "即服务 (aaS)即服务这一词来自第三方提供的 云计算 服务，可以降低本地维护架构的成本，而实现关注自身事务。通过将自身部署在本地的硬件和软件，部分或全部交给第三方管理和维护，就可称为使用了即服务 (aSS)。常见的即服务有三种：基础架构即服务IaaS, 平台即服务PaaS, 软件即服务SaaS. 其中IaaS 指服务商为用户提供基础架构，而软件硬件需要用户管理和维护，例如阿里云ECS服务；...", "content": "即服务 (aaS)即服务这一词来自第三方提供的 云计算 服务，可以降低本地维护架构的成本，而实现关注自身事务。通过将自身部署在本地的硬件和软件，部分或全部交给第三方管理和维护，就可称为使用了即服务 (aSS)。常见的即服务有三种：基础架构即服务IaaS, 平台即服务PaaS, 软件即服务SaaS. 其中IaaS 指服务商为用户提供基础架构，而软件硬件需要用户管理和维护，例如阿里云ECS服务；PaaS 指服务商不仅为用户提供基础架构，同时提供硬件的维护，用户只需要在服务商提供的平台上开发应用即可，而其他部分的正常运行不需要考虑；SaaS 则是服务商为用户提供完整的 WebApp 服务，这里的服务通过付费订阅的方式获得，且不同用户之间相互隔离，用户不需要关注其背后的软件实现，硬件部署以及基础框架维护。不同即服务覆盖范围，图片来自RedhatTopics" }, { "title": "Mamba-Frequency based method相关工作阅读", "url": "/posts/Mamba-based/", "categories": "图像处理", "tags": "深度学习, 图像处理", "date": "2024-06-03 20:53:00 +0800", "snippet": "Mamba在图像处理中的应用Mamba自 2023 年底以来在多个领域衍生多种子方法，同时在图像处理等领域也有一定发展，最近阅读到两篇工作，都从频率的角度尝试进行去雨，虽创新程度不高，但也提供Mamba改进的几个视角。FreqMambaMamba 方法可以实现长距离的建模而相对不容易出现遗忘的情况，但是该方法在原始领域作用为处理长序列语言建模，这样简单将 SSM 建模方法引入图像处理必然会出...", "content": "Mamba在图像处理中的应用Mamba自 2023 年底以来在多个领域衍生多种子方法，同时在图像处理等领域也有一定发展，最近阅读到两篇工作，都从频率的角度尝试进行去雨，虽创新程度不高，但也提供Mamba改进的几个视角。FreqMambaMamba 方法可以实现长距离的建模而相对不容易出现遗忘的情况，但是该方法在原始领域作用为处理长序列语言建模，这样简单将 SSM 建模方法引入图像处理必然会出现一定割裂，例如其逐行 scan 操作破坏了图像的二维空间属性，这样 Mamba 就需要额外处理这种换行引起的空间位置差别过大的关系建模，如下如：原始mamba直接应用在图像的scanFreqMamba 考虑从频率域出发，采用小波包变换，将图像拆分为多级不同频率下的图像，每一级都保留全局的结构信息，因为每个块现在包含所有的图像信息 (丢失一定频率)，可以降低上述逐行扫描过程中不同位置之间的隔阂，具体为：scan元素为不同分辨率下的频域图像分量具体的，作者给出如下结构：FreqMamba结构该方法也采用UNet框架，BasicBlock，为三分支路线，分别为：空间域图像输入SSM，频域图像输入SSM，以及频域下相位谱和频谱卷积提取特征。FourierMamba相比 FreqMamba, 本文作者修改了原始Mamba扫描token的顺序，将其改为之字形扫描 (Zigzag scan)将逐行扫描修改为之字形扫描作者认为直接使用逐行扫描频域空间，不利于相邻频率之间的特征交互，所以采用如此之字形的方式，使得相邻频率的像素尽可能靠近。两文结果两方法的去雨效果量化结果可以看出 MambaBased 方法与现有的 TransformerBased 方法差距仍旧不大，且实际的Mamba训练时长感人，短时间内该方法 (MambaBased) 还需要进行观察。总结上述方法尝试从频率域的角度实现图像去雨，分别采用直接嵌入频域角度的图像信息和修改Mamba扫描函数来提升图像去雨质量，但是Mamba本身的长距离建模能力能够处理这样的空间隔阂，故两人在不同的角度提出的改进提升效果不明显。使用Mamba这种长距离建模的方法对于去除雨痕是否是关键的仍有待商榷。" }, { "title": "套接字Socket", "url": "/posts/LinuxSocket/", "categories": "Linux", "tags": "笔记", "date": "2024-05-29 12:23:00 +0800", "snippet": "定义 Socket 指二元组 $(ip, port)$, 即Socket基础中的Socket地址，所有的接口定义都在 &lt;sys/socket.h&gt; 头文件中，该API可实现功能： 创建，命名和监听socket，读取和设置socket选项；以及接受，发起连接，读写数据，获取地址信息和检测带外标记，Socket 有三种地址类型 sockaddr ：Unix(sockaddr_un...", "content": "定义 Socket 指二元组 $(ip, port)$, 即Socket基础中的Socket地址，所有的接口定义都在 &lt;sys/socket.h&gt; 头文件中，该API可实现功能： 创建，命名和监听socket，读取和设置socket选项；以及接受，发起连接，读写数据，获取地址信息和检测带外标记，Socket 有三种地址类型 sockaddr ：Unix(sockaddr_un), TCP/IPv4(sockaddr_in), TCP/IPv6(sockaddr_in6)在socket地址中，所有的ip地址都保存为对应的 网络字节序 ，一般在记录日志时才会将ip地址转换为对应的点分十进制字符串表示1。在 &lt;arpa/inet.h&gt; 保存网络字节序地址和点分十进制字符串的转换函数，需要注意的是其中 inet_ntoa 函数返回结果为静态地址，不能保证线程安全（不可重入）。Socket使用创建 引入 &lt;sys/socket.h&gt; 后，可使用 socket() 函数创建，对应的参数和返回类型查询手册可得： int socket(int domain, int type, int protocol);domain 表示对应的协议族，type 表示使用的传输层协议，protocol 不使用，直接设置为0.命名 将socket与socket地址绑定的操作称为 给socket命名。一般在服务端中需要命名socket，而在客户端中只需要匿名的方式获得系统自动分配的socket地址即可。命名则使用 bind() 函数实现，定义为： int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);监听 服务端命名socket后，并不能立即接收客户端连接，需要使用系统调用 listen() 创建一个监听队列来存放待处理的客户端连接，这个队列我们也称作全连接队列，特指已经完成三次握手后的连接，同时该文件描述符对应的可读事件绑定为全连接队列内容非空，这样我们可以通过系统调用 select, poll 或者 epoll 监听该 fd 对应的 EPOLLIN 实现监听是否有客户端连接。 int listen(int sockfd, int backlog)sockfd 指定被监听的socket，而 backlog 提示内核监听队列的最大长度，如果超过该长度 (backlog指定的长度) 服务端则不会受理新的客户端连接，同时客户端会受到拒绝信息 ECONNREFUSED接受连接 accept() 系统调用可从监听队列中接受一个连接： int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)sockfd 是指监听socket，成功时 accept() 返回连接的socket发起连接 客户端通过系统调用 connect() 与服务端建立连接： int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);关闭连接 关闭连接指关闭该连接对应的socket，通过系统调用 close() 完成： int close(int fd);close() 调用减少socket的引用计数，当socket对应的引用计数为0时该连接关闭。 如果需要事实上关闭连接，则通过系统调用 shutdown() 完成： int shutdown(int sockfd, int howto);其中 howto 参数决定shutdown的行为，分为写关闭，读关闭和完全关闭。写关闭控制进程不可再向sockfd写操作，同时会在关闭连接前将发送缓冲区的数据全部发送；读关闭则会丢弃接收缓冲区中的所有数据。数据读写根据传输层协议分别提供专用的系统调用，对于TCP流，读 recv() 写 send(), 对于UDP流，读 recvfrom() 写 sendto(). 其中TCP部分： ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t send(int sockfd, const void *buf, size_t len, int flags);两者都指定了需要读取或写入的sockfd，buf指读或写缓冲区，len为缓冲区大小，flags为标识符，表示额外的控制，并且两者都返回实际读和写的大小。 对于UDP部分： ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);相比TCP，UDP是无连接的通信方式，所以每次发送或接收都需要指定对应的socket地址，可以看参数，对应的有 *_addr 以及 addrlen.当UDP部分的数据包socket执行connect后，可不指定 socket_addr 和 addrlen, 但传输层仍然会使用UDP的传输方式，只是自动的从sockfd中获得对应的socket地址和长度。 同时可以使用通用的系统调用 sendmsg() 和 recvmsg(). 该调用可以同时使用TCP流数据和UDP数据包。 ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags); ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);其中 struct msghdr 结构体如下：struct msghdr { void *msg_name; /* Optional address */ socklen_t msg_namelen; /* Size of address */ struct iovec *msg_iov; /* Scatter/gather array */ size_t msg_iovlen; /* # elements in msg_iov */ void *msg_control; /* Ancillary data, see below */ size_t msg_controllen; /* Ancillary data buffer len */ int msg_flags; /* Flags (unused) */};其中 msg_name 为socket地址，当操作的是TCP流数据时，不需要指定该变量，之间传入 NULL 即可，对于UDP数据包则需要指定对应的socket地址。带外数据带外数据 又称为 加速数据，为紧急数据，可以通过系统调用 sockatmark() 判断 sockfd 是否处于带外标记，下一次读取到的数据是否为带外数据。如果是，则可以通过 MSG_OOB 标志的 recv 系统调用来接收带外数据。地址信息函数可以根据sockfd获取对应的本端地址以及远端地址： 本端地址 int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen); int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);需要注意的是，该系统调用成功时返回 0 失败返回 -1.socket描述符设置 利用系统调用获取或设置描述符设置： int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen); int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);需要注意的是，该系统调用成功时返回 0 失败返回 -1.网络信息获取即获取socket地址中的IP地址和端口号，分别代表对应的主机名和服务。获取主机信息 其中获取主机名： struct hostent *gethostbyname(const char *name); 通过 &lt;netdb.h&gt;获取 struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type); 通过&lt;sys/socket.h&gt;获取可分别根据主机名或IP地址来获得完整的主机网络信息 hostent，其结构包括主机名以及IP地址信息：struct hostent { char *h_name; /* official name of host */ char **h_aliases; /* alias list */ int h_addrtype; /* host address type */ int h_length; /* length of address */ char **h_addr_list; /* list of addresses */}获取服务信息 获取服务信息，也即端口号和服务名，通过 &lt;netdb.h&gt; 获取： struct servent *getservbyname(const char *name, const char *proto); struct servent *getservbyport(int port, const char *proto);可分别从服务名和端口号获得完整的服务信息 servent，其结构包括服务名和端口号：struct servent { char *s_name; /* official service name */ char **s_aliases; /* alias list */ int s_port; /* port number */ char *s_proto; /* protocol to use */} 然后可已通过主机名和服务名获得对应地址信息： int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res); void freeaddrinfo(struct addrinfo *res);需要注意，该系统调用会动态分配存储来存放结果，所以使用结束后需要手动释放结果。struct addrinfo { int ai_flags; int ai_family; int ai_socktype; int ai_protocol; socklen_t ai_addrlen; struct sockaddr *ai_addr; char *ai_canonname; struct addrinfo *ai_next;};获取主机和服务信息 估计传入的socket地址，返回该socket地址对应的主机和服务信息： int getnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, int flags);一个包含简单的服务端与客户端连接流程Socket IO通信管道创建 Linux 提供系统调用用于创建管道描述符，可以实现不同进程之间的单向通信： int pipe(int pipefd[2])，该系统调用来自 &lt;unistd.h&gt;.其中pipefd[0] 描述符用于从对应文件读；pipefd[1] 用于向对应文件写。 同时 socket 提供了双向通信的管道： int socketpair(int domain, int type, int protocol, int sv[2])，该系统调用来自 &lt;sys/socket.h&gt;但是该函数接口只能够接收 domain 为 AF_UNIX 的协议簇，意味只接收本机多个进程之间的通信。复制描述符 如果需要重定向标准输入输出流，可以通过复制描述符实现： int dup(int oldfd); 创建一个尽可能小的描述符绑定至 oldfd 指向的文件 int dup2(int oldfd, int newfd); 创建一个不小于 newfd 的描述符指向 oldfd 指向的文件需要注意的是，复制描述符并不会继承原有描述符的属性。文件描述符读写 : ssize_t readv(int fd, const struct iovec *iov, int iovcnt) ssize_t writev(int fd, const struct iovec *iov, int iovcnt)该函数对来自 &lt;sys/uio.h&gt; 成功则返回对应的读/写字节数，失败则返回 -1并设置 errno文件传递 该方法称为零拷贝函数，不需要经过用户缓冲区，完全在内核中执行，实现从文件到套接字的传递： ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)该方法从 in_fd 所指文件至 out_fd 所指套接字的 offset 位置写入 count 字节。如果成功则返回实际传送的字节数量，否则返回 -1 同时设置 errno内存申请 该函数可以申请一段内存空间，可用于作为进程间通信的共享内存，或者将文件映射其中： void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t length);addr 指用户指定的内存起始地址，可以传递 NULL 不指定，则由内核决定，申请 length字节的空间，并根据 prot 决定该内存空间的该段空间被修改后程序的行为，包括该段内存空间是否共享，是否文件映射而来等；指定 fd 所指文件 offset 位置处开始映射内容，该函数成功则返回对应的内存地址，否则返回 -1 并设置 errno.文件描述符之间传递数据 要求至少有一个管道文件描述符 ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);管道文件描述符之间传递数据 要求两个都是管道文件描述符： ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags)修改文件描述符的属性 从库 &lt;fcntl.h&gt;中获取该函数，可用于控制文件描述符常见的属性： int fcntl(int fd, int cmd, ...)第三个是可选参数，根据 cmd 决定实际是否需要以及需要的类型。注释 表示为形如：”XX.XX.XX.XX” 或 “XX:XX:XX:XX:XX:XX” 的地址表示方法 &#8617;&#xfe0e; " }, { "title": "动规经典问题-背包", "url": "/posts/acwing%E8%83%8C%E5%8C%85/", "categories": "算法, 动态规划, 背包问题", "tags": "算法, 动态规划, 背包问题", "date": "2024-05-26 23:38:00 +0800", "snippet": "01背包问题描述有n项物品，每项物品的价值为v，m体积的背包中选取价值最高的方案，限定每类物品最多只能选择1次。思考思考该问题需要从状态空间的角度出发，也就是前 i, i &lt;= n 个物品，体积为 j, j &lt;= m 的情况下，能够获得价值最高的方案是什么，并把该状态保存下来，用空间换时间，在计算其他状态的价值时候可以直接取到之前的状态结果。考虑状态空间$f(i,j)$，有两个转...", "content": "01背包问题描述有n项物品，每项物品的价值为v，m体积的背包中选取价值最高的方案，限定每类物品最多只能选择1次。思考思考该问题需要从状态空间的角度出发，也就是前 i, i &lt;= n 个物品，体积为 j, j &lt;= m 的情况下，能够获得价值最高的方案是什么，并把该状态保存下来，用空间换时间，在计算其他状态的价值时候可以直接取到之前的状态结果。考虑状态空间$f(i,j)$，有两个转移条件，也就是是否使用第 i 项：\\[f(i,j)=\\begin{cases} f(i - 1, j), &amp;\\text{不用第 i 项} \\\\ f(i - 1, j - v_i) + w_i,&amp;\\text{用第 i 项}\\end{cases}\\]同时因为 f(i,j) 仅与 f(i-1,*) 相关，所以可以将状态空间优化为一维滚动数组，这里需要注意的是：更新 f(j) 应该倒序更新，这样可以保证更新参考的值实际上来自 f(i-1,*) .代码#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1010;int v[N], w[N];int f[N];// f元素表示状态集合// f[i][j] 表示i项物品在体积为j的背包中的最大价值// 1. 第i项物品使用： f[i][j] = f[i - 1][j - v[i]] + w[i];// 2. 第i项物品不使用：f[i][j] = f[i - 1][j]// 因此最优选择为：f[i][j] = max(f[i - 1][j - v[i]] + w[i], f[i - 1][j])// 同时因为f[i][j]更新仅根据第i-1项，和小于等于体积j的条件，故可以采用滚动数组的方式进行更新// 即：// f[j] = max(f[j - v[i] + w[i], f[j])，同时j更新顺序从 max_vol -&gt; 0int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++){ int vol, wealth; cin &gt;&gt; vol &gt;&gt; wealth; v[i] = vol; w[i] = wealth; } for(int i = 1; i &lt;= n; i++){ for(int j = m; j &gt;= 1; j--){ if(j - v[i] &gt;= 0) f[j] = max(f[j - v[i]] + w[i], f[j]); } // for(int k = 1; k &lt;= m; k++) cout &lt;&lt; f[k] &lt;&lt; \" \"; // cout &lt;&lt; endl; } cout &lt;&lt; f[m] &lt;&lt; endl; return 0;}完全背包问题描述相比01背包，完全背包不限制每项物品的个数。思考其状态方程如下：\\[\\begin{equation} f(i,j)=\\max{\\{f(i - 1, j), f(i - 1,j - v_i) + w_i, f(i-1, j-2v_i) + 2w_i, \\dots\\}} \\label{eq:1}\\end{equation}\\]而$f(i,j-v_i)$状态方程为：\\(\\begin{equation} f(i,j-v_i)=\\max{\\{f(i - 1, j-v_i), f(i - 1,j - 2v_i) + w_i, f(i-1, j-3v_i) + 2w_i, \\dots\\}} \\label{eq:2}\\end{equation}\\)light可以观察到 \\eqref{eq:1} 为 \\eqref{eq:2} 子式，故可得：\\[\\begin{equation} f(i,j)=\\max{\\{f(i-1,j),f(i,j-v_i)+w_i\\}} \\label{eq:3}\\end{equation}\\]和01背包类似，完全背包的 f(i,j) 也仅与 f(i-1,*) 相关，所以也可以用一维滚动数组进行优化。与01背包不同的是，更新需要参考的对象应为 f(i,*) ，所以这里 f(j) 应该正序更新.代码#include &lt;iostream&gt;using namespace std;const int N = 1010;int f[N];int v[N], w[N];/** f[i][j]表示状态空间，前i项物品，空间为j时，背包最大价值 1. 使用0,1,...,j/v[i]项i物品: f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i] * 1] + 1 * w[i], f[i - 1][j - v[i] * 2] + 2 * w[i], ... , f[i - 1][j - v[i] * j / v[i]]) + j / v[i] * w[i]; f[i][j] = max(f[i - 1][j], f[i][j - v] + w[i]) 转为滚动数组表达,因为第二项采用的是当前行的数值，故j从v[i]出发到max_vol值： f[j] = max(f[j], f[j - v[i]] + w[i]);**/int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int i = 1; i &lt;= n; i++) for(int j = v[i]; j &lt;= m; j++) f[j] = max(f[j], f[j - v[i]] + w[i]); // for(int j = 1; j &lt;= m; j++) // if(j - v[i] &gt;= 0) // f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;}多重背包问题相比完全背包，多重背包要求每项物品最多仅使用s个。思考故对于状态 f(i, j) :\\[\\begin{equation} f(i, j) = \\max{\\{f(i - 1, j), f(i-1, j - v_i)+w_i, \\dots , f(i-1, j - s_i \\cdot v_i)+s_i\\cdot w_i\\}}\\end{equation}\\]通过上述状态转移，可以在数据量不大的情况下，朴素遍历所有情况，对应的复杂度为 O(nms)优化方案： 该方法无法简单的采用完全背包的方式计算，但可以看出该公式可以采用 单调队列 优化，在第二层遍历的过程中，将当前状态加入 单调队列 中，可将时间复杂度降低至 O(nm) , 这里暂时不考虑怎么做，留个链接多重背包单调队列优化以后看。 同时该方法可以通过将多个相同的物品拆分为多项 大物品 退化为01背包问题 当第i项物品最多可以选择s个时，需要拆分成多个大物品，这些大物品的组合结果应当覆盖所有的0~s个物品的情况。以 s=200 为例，应该拆分为 1, 2, 4, 8, 16, 32, 64, 73 其中的所有组合情况可以覆盖所需的状态。最终 多重背包 问题退化为 01背包 问题且物品项数根据拆分的结果作对应扩充，且最终的结果等效，对应的时间复杂度为 O(m logns) . 代码#include &lt;iostream&gt;using namespace std;const int N = 110;int f[N][N];int v[N], w[N], s[N];/* 朴素计算，通过遍历背包中单项物品的每一种情况计算结果，即：从0~s个物品遍历比较*/int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i]; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++){ q.clear(); for(int j = 1; j &lt;= m; j++){ for(int k = 0; k &lt;= s[i]; k++){ if(j - v[i] * k &gt;= 0) f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); } // cout &lt;&lt; f[i][j] &lt;&lt; \" \"; } // cout &lt;&lt; endl; } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;}二进制优化为多个 大物品 ：#include &lt;iostream&gt;using namespace std;const int N = 20010;int f[N];int v[N], w[N];int main(){ int n, m; cin &gt;&gt; n &gt;&gt; m; int cnt = 0; for(int i = 0; i &lt; n; i++){ int vi, wi, si; cin &gt;&gt; vi &gt;&gt; wi &gt;&gt; si; // 将si项物品拆分为1,2,4,...,si % n 个大物品 int s = 1; while(si &gt;= s){ ++cnt; v[cnt] = vi * s; w[cnt] = wi * s; si -= s; s *= 2; } if(si){ ++cnt; v[cnt] = vi * si; w[cnt] = wi * si; } } n = cnt; for(int i = 1; i &lt;= n; i++){ for(int j = m; j &gt;= v[i]; j--){ f[j] = max(f[j], f[j - v[i]] + w[i]); } } cout &lt;&lt; f[m] &lt;&lt; endl; return 0;}分组背包分组背包将物品分为多个组，每个组中有多项物品，同时要求每个组选择1个物品。代码#include &lt;iostream&gt;using namespace std;const int N = 110;int n, m;int v[N][N], w[N][N], s[N];int f[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; s[i]; for(int j = 1; j &lt;= s[i]; j++) cin &gt;&gt; v[i][j] &gt;&gt; w[i][j]; } for(int i = 1; i &lt;= n; i++) for(int j = m; j &gt;= 0; j--) for(int k = 1; k &lt;= s[i]; k++) if(j - v[i][k] &gt;= 0) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;}" }, { "title": "输入及常用格式", "url": "/posts/%E8%BE%93%E5%85%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%A0%BC%E5%BC%8F/", "categories": "教程, 写作", "tags": "教程", "date": "2024-05-25 11:33:00 +0800", "snippet": "标题H1 - 一级标题H2 - 二级标题 从二级标题开始创建目录.H3 - 三级标题H4 - 四级标题段落记争各较农即象器曲天感内边文翻究送度油宪副拿。践井例看标胞板例沿。去迫离优体端散吸实岩房啊参读年站志弦微采跳旧花穿华航已拉运练们社。算镇破们错行派笑翻技境结系时造许洲叶？千字地斗思政父己致费却部若化植修星爱袁轮宣船，鲜力星似什与。各础系课候侵划奏花效油放鲜因预策临夜乡教欢一节初便王右通...", "content": "标题H1 - 一级标题H2 - 二级标题 从二级标题开始创建目录.H3 - 三级标题H4 - 四级标题段落记争各较农即象器曲天感内边文翻究送度油宪副拿。践井例看标胞板例沿。去迫离优体端散吸实岩房啊参读年站志弦微采跳旧花穿华航已拉运练们社。算镇破们错行派笑翻技境结系时造许洲叶？千字地斗思政父己致费却部若化植修星爱袁轮宣船，鲜力星似什与。各础系课候侵划奏花效油放鲜因预策临夜乡教欢一节初便王右通容画，粉迅露按钢说般块形。然心气防审凯议公八德理侵乎西央航终夜须她律念育置改执束额。如章革金书耐起射它划，央或界罗带毫怎另粒执限践率报生虽张值突些会衡南观，祖仍厂随举士人工互管散设航袁歌黑总胜斤，放乱岁封职位夜足界乙意不缺里参视上帝翻青面硫，培还非环后故括烟医孙滑秋都课青你局执义。入底刘探成资倒回板胶识。送念又价群通身结绝端起含晚使岩移吗攻试能。证织温永区想和响迫随习增经新晚蒸笔面远。跑这日露号座输王既免具金知银相选景松映鸡列而命父轮易提，红唱约担风两著爱广字写布出想沉酸承孔七乱雷犯印唱铁要并，面虽围或夜传矛及皇至六重却己世钟基区织，右如南景张配书接迅探城包两影构较亮些张效办报，麼母你历员企什些当各医苗用球犯会斤通点几缩细真简置前温。注研浓得宪城严回对附燃良术句测雷。热坐喜级任料在能裂乎证将早未落察打量纪越酒态品往指影势没。村区田武引难欢坏积见的阻元境施几置先松吗烟能超书肉煤财。创许率娘临考温呼微靠首席问乾心，回位绿来钟中考心月市初句操其师双红若皮斗合教试，架乾记於渐从养跟跑千算论养卷发首房母江月裂首视滑断讨危方等争，准没孙产住威老老害构五展环构轴员想排占团尔下重斗操升谈衣。列表有序列表 第一项 第二项 第三项无序列表 章 节 段 ToDo 列表 Job Step 1 Step 2 Step 3 描述列表 太阳 太阳系的恒星 月球 地球的卫星块引用 This line shows the block quote.块引用需要在段前添加 &gt;意图 (Prompts)意图为liquid扩展语法，通过在块引用下添加 {: .prompt-tip } 实现，其中 prompt 类型有四种：.prompt-tip, .prompt-info, .prompt-warning, .prompt-danger An example showing the tip type prompt. An example showing the info type prompt. An example showing the warning type prompt. An example showing the danger type prompt.表表插入格式为：每行 | content1 | content2 | content3 | ，由多行构成，设定内容对齐 | :-- | :-- | --: | Company Contact Country Alfreds Futterkiste Maria Anders Germany Island Trading Helen Bennett UK Magazzini Alimentari Riuniti Giovanni Rovelli Italy Linkshttp://127.0.0.1:4000Footnote点击可跳转对应的角标1, 另外一个角标2.Inline codeThis is an example of Inline Code.FilepathHere is the /path/to/the/file.extend.代码块通用This is a common code snippet, without syntax highlight and line number.指定语言类型if [ $? -ne 0 ]; then echo \"The command was not successful.\"; #do the needful / exitfi;给定文件名@import \"colors/light-typography\", \"colors/dark-typography\";MathematicsThe mathematics powered by MathJax:\\[\\begin{equation} \\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6} \\label{eq:series}\\end{equation}\\]We can reference the equation as \\eqref{eq:series}.When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\]Mermaid SVG gantt title Adding GANTT diagram functionality to mermaid apple :a, 2017-07-20, 1w banana :crit, b, 2017-07-23, 1d cherry :active, c, after b a, 1dImagesDefault (with caption)Full screen width and center alignmentLeft alignedFloat to leftPraesent maximus aliquam sapien. Sed vel neque in dolor pulvinar auctor. Maecenas pharetra, sem sit amet interdum posuere, tellus lacus eleifend magna, ac lobortis felis ipsum id sapien. Proin ornare rutrum metus, ac convallis diam volutpat sit amet. Phasellus volutpat, elit sit amet tincidunt mollis, felis mi scelerisque mauris, ut facilisis leo magna accumsan sapien. In rutrum vehicula nisl eget tempor. Nullam maximus ullamcorper libero non maximus. Integer ultricies velit id convallis varius. Praesent eu nisl eu urna finibus ultrices id nec ex. Mauris ac mattis quam. Fusce aliquam est nec sapien bibendum, vitae malesuada ligula condimentum.Float to rightPraesent maximus aliquam sapien. Sed vel neque in dolor pulvinar auctor. Maecenas pharetra, sem sit amet interdum posuere, tellus lacus eleifend magna, ac lobortis felis ipsum id sapien. Proin ornare rutrum metus, ac convallis diam volutpat sit amet. Phasellus volutpat, elit sit amet tincidunt mollis, felis mi scelerisque mauris, ut facilisis leo magna accumsan sapien. In rutrum vehicula nisl eget tempor. Nullam maximus ullamcorper libero non maximus. Integer ultricies velit id convallis varius. Praesent eu nisl eu urna finibus ultrices id nec ex. Mauris ac mattis quam. Fusce aliquam est nec sapien bibendum, vitae malesuada ligula condimentum.Dark/Light mode &amp; ShadowThe image below will toggle dark/light mode based on theme preference, notice it has shadows.Video 嵌入视频 插入代码 {% include embed/bilibili.html id=视频id %}Youtube 视频：Bilibili 视频：反向角标 (角标源) 角标源位置 &#8617;&#xfe0e; 第二个角标源位置 &#8617;&#xfe0e; " }, { "title": "如何编写博客", "url": "/posts/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2/", "categories": "教程, 写作", "tags": "教程", "date": "2024-05-24 20:39:10 +0800", "snippet": "尝试了解如何编写博客试着用一下自己常用的论文格式地址论文补充材料github地址项目/期刊/会议地址作者主页关键字摘要信息贡献背景及相关工作方法论一个公式：\\(\\begin{equation} Test\\_func = \\sum_{i = 1}^{\\inf}\\frac{1}{i} \\end{equation}\\)", "content": "尝试了解如何编写博客试着用一下自己常用的论文格式地址论文补充材料github地址项目/期刊/会议地址作者主页关键字摘要信息贡献背景及相关工作方法论一个公式：\\(\\begin{equation} Test\\_func = \\sum_{i = 1}^{\\inf}\\frac{1}{i} \\end{equation}\\)" } ]
