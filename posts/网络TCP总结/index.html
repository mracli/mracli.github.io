<!doctype html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="网络TCP总结" /><meta name="author" content="墨墨鱼" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="学无止境，苦海无涯。正因知识无穷，而学无止境；苦海虽无涯，心中仍燃烧着对真理的渴望，而这份渴望，是引领自我不断进步的动力" /><meta property="og:description" content="学无止境，苦海无涯。正因知识无穷，而学无止境；苦海虽无涯，心中仍燃烧着对真理的渴望，而这份渴望，是引领自我不断进步的动力" /><link rel="canonical" href="https://mracli.github.io/posts/%E7%BD%91%E7%BB%9CTCP%E6%80%BB%E7%BB%93/" /><meta property="og:url" content="https://mracli.github.io/posts/%E7%BD%91%E7%BB%9CTCP%E6%80%BB%E7%BB%93/" /><meta property="og:site_name" content="墨墨鱼的博客" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-09-18T16:33:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="网络TCP总结" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"墨墨鱼","url":"https://github.com/mracli/"},"dateModified":"2024-09-18T16:33:00+08:00","datePublished":"2024-09-18T16:33:00+08:00","description":"学无止境，苦海无涯。正因知识无穷，而学无止境；苦海虽无涯，心中仍燃烧着对真理的渴望，而这份渴望，是引领自我不断进步的动力","headline":"网络TCP总结","mainEntityOfPage":{"@type":"WebPage","@id":"https://mracli.github.io/posts/%E7%BD%91%E7%BB%9CTCP%E6%80%BB%E7%BB%93/"},"url":"https://mracli.github.io/posts/%E7%BD%91%E7%BB%9CTCP%E6%80%BB%E7%BB%93/"}</script><title>网络TCP总结 | 墨墨鱼的博客</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="墨墨鱼的博客"><meta name="application-name" content="墨墨鱼的博客"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.27.20/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { let self = this;this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { self.clearMode(); } self.notify(); }); if (!this.hasMode) { return; } if (this.isDarkMode) { this.setDark(); } else { this.setLight(); } } get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isPreferDark() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); }get modeStatus() { if (this.hasMode) { return this.mode; } else { return this.isPreferDark ? ModeToggle.DARK_MODE : ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); }notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { this.clearMode(); } else { if (this.isPreferDark) { this.setLight(); } else { this.setDark(); } } this.notify(); } } const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/favicons/icon.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a><h1 class="site-title"> <a href="/">墨墨鱼的博客</a></h1><p class="site-subtitle fst-italic mb-0">wubba lubba dub dub</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>关于</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="btn btn-link nav-link" aria-label="Switch Mode" id="mode-toggle"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/mracli" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="javascript:location.href = 'mailto:' + ['mracli','qq.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">首页</a> </span> <span>网络TCP总结</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> 文章</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">取消</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>网络TCP总结</h1><p class="post-desc fw-light mb-4">学无止境，苦海无涯。正因知识无穷，而学无止境；苦海虽无涯，心中仍燃烧着对真理的渴望，而这份渴望，是引领自我不断进步的动力</p><div class="post-meta text-muted"> <span> 发表于 <time data-ts="1726648380" data-df="YYYY/MM/DD" data-bs-toggle="tooltip" data-bs-placement="bottom" > 2024/09/18 </time> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://github.com/mracli/">墨墨鱼</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="6525 字" > <em>36 分钟</em>阅读</span></div></div></div></header><div class="content"><h2 id="linux-中的-tuntap-设备"><span class="me-2">Linux 中的 TUN/TAP 设备</span><a href="#linux-中的-tuntap-设备" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在学习CS144过程中，作者实验指导中讲述到，内核实现运输层和网络层的数据包封装，如果我们自己也想自行进行封装，则需要采用 TUN/TAP 设备文件，实现自行封装，并提供封装结果。</p><p>这里 TUN 设备作用则是作为网络层的 IP 类似的协议实现对运输层及更高层的数据进行封装；而 TAP 设备则提供数据链路层中的协议实现，可对网络层及更上层的数据进行封装。</p><p>其中 TUN/TAP 设备文件都存放在 <code class="language-plaintext highlighter-rouge">/dev/net/</code> 下。</p><p>创建 TUN/TAP 设备可以参考: <a href="https://docs.kernel.org/networking/tuntap.html">Linux Kernel tuntap ref</a></p><h2 id="tcp-相关"><span class="me-2">TCP 相关</span><a href="#tcp-相关" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>TCP 是一种基于IP栈上实现的一种双工有连接的可靠字节流传输协议，通过有效的职责划分，可将 TCP 栈分为多层结构：字节流，重组器，发送器，接收器，连接器，相对关系如下：</p><p><a href="/assets/img/网络中的常识/tcp_stack_flow.png" class="popup img-link shimmer"><img src="/assets/img/网络中的常识/tcp_stack_flow.png" alt="" loading="lazy"></a></p><p>这些组件共同构成一个 tcp 实体，每个组件分别实现功能，仅为简化的实现，完成 TCP 必要功能的实现：</p><ul><li><strong>字节流(bytestream)</strong>: 流式内容的基本容器，记录流中 pushed 和 popped 的字节数量，也可手动关闭字节流；<li><strong>流重组器(reassembler)</strong>: 接收端字节流的 wrapper ，由于 ip stack 的特性，即数据包在网络中的传输是乱序的，所以接收端采用重组器缓存接收窗口范围内的字节，并在合适的情况下组装字节流，发送到 bytestream 中；<li><strong>接收器(receiver)</strong>: 负责接收 peer 发送来的 tcp segment (序列长度不能为0)，根据接收到的 segment ，判断当前的 fsm 状态，包括：<code class="language-plaintext highlighter-rouge">listen</code>, <code class="language-plaintext highlighter-rouge">syn_recv</code>, <code class="language-plaintext highlighter-rouge">fin_recv</code>, <code class="language-plaintext highlighter-rouge">closed</code>, <code class="language-plaintext highlighter-rouge">error</code>, 同时返回当前可以接受的接收窗口，并保证接受到的字节流可以有序的接收(流重组器重新组装字节流)；<li><strong>发送器(sender)</strong>: 负责主动向对端发起建立连接，根绝对端的接收窗口更新自身的发送窗口(推断对端接收能力)，发送字节流，同时保证发送的字节流可以可靠地发送出去(超时重传,推断网络拥塞情况),<li><strong>连接器(connection)</strong>: 负责可选择地维持 TCP 连接( Keepalive 操作); 根据接受的 tcp segment判断是 ack segment还是 sequence segment, 并将 segment 送入 sender 兼或 receiver (捎带机制，除了 syn seg, 发送的 seq 会携带自身 receiver 的接收窗口状态，也即 SEQ+ACK seg); 根据对端和自身的 sender 和 receiver 互相发送接收的 segment 来判断当前 tcp 连接的状态，并给出对应的行为(大部分 sender 和 receiver 已经实现，Connection 需要实现关闭连接的 closed_wait 操作, 管理 sender 发送的 segment 重传次数过多则转为 <code class="language-plaintext highlighter-rouge">error</code>);</ul><p>这里给出具体的 TCP segment传入传出的流图：</p><p><a href="/assets/img/网络中的常识/tcp_stack_segments.png" class="popup img-link shimmer"><img src="/assets/img/网络中的常识/tcp_stack_segments.png" alt="" loading="lazy"></a></p><p>后面针对上述的各个组件分别进行解释。</p><h3 id="字节流bytestream"><span class="me-2">字节流(ByteStream)</span><a href="#字节流bytestream" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了实现一个可为上级提供可靠的字节流服务，该字节流内部需要有</p><p><strong>缓冲区</strong>：可以缓存部分字节流的内容，当上层(应用层软件)从字节流中读取部分字节后，字节流将该部分弹出；从下层(外部对端segment)接受的字节有序的放入字节流缓冲区中。我们可以看出这里需要确定能够缓冲的最大容量(capacity);</p><p><strong>预料外的情况</strong>：需要主动放弃继续更新字节流，同时能够提供接口告知外部自身已经出现异常;</p><p><strong>流结束</strong>：提供接口告知外部当前字节流已经达到结尾(eof, end of file).</p><p>其中可靠性可以参考<a href="https://datatracker.ietf.org/doc/html/rfc793#page-4">RFC793</a>的描述：</p><p>The TCP must recover from data that is damaged, lost, duplicated, or delivered out of order by the internet communication system.</p><p>这里针对字节流的要求则为保证接收到的字节能够正确组装到末尾。</p><p>这样的字节流接口为：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">ByteStream</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">ByteStream</span><span class="p">(</span> <span class="kt">uint64_t</span> <span class="n">capacity</span> <span class="p">);</span>

    <span class="kt">void</span> <span class="n">set_error</span><span class="p">()</span> <span class="p">{</span> <span class="n">error_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">error</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">error_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="kt">uint64_t</span> <span class="n">capacity_</span> <span class="p">{};</span>      <span class="c1">// ByteStream可以同时容纳的容量</span>
    <span class="kt">bool</span> <span class="n">error_</span> <span class="p">{};</span>        
    <span class="kt">bool</span> <span class="n">closed</span> <span class="p">{};</span>             <span class="c1">// 字节流是否已经发送到末尾</span>

    <span class="kt">uint64_t</span> <span class="n">pushed_size_</span> <span class="p">{};</span>   <span class="c1">// 从对端发送并压入ByteStream的字节数</span>
    <span class="kt">uint64_t</span> <span class="n">popped_size_</span> <span class="p">{};</span>   <span class="c1">// 发送给客户端并弹出的ByteStream的字节数</span>
<span class="p">}</span>
</pre></table></code></div></div><p>同时根据该字节流给出 writer 和 reader 的子类实现：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Reader</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Writer</span><span class="p">;</span>

<span class="c1">// ByteStream 在64位系统中 size: 64字节 8字节对齐</span>
<span class="k">class</span> <span class="nc">ByteStream</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">ByteStream</span><span class="p">(</span> <span class="kt">uint64_t</span> <span class="n">capacity</span> <span class="p">);</span>

    <span class="c1">// 辅助接口类，用于访问字节流</span>
    <span class="n">Reader</span><span class="o">&amp;</span> <span class="n">reader</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Reader</span><span class="o">&amp;</span> <span class="n">reader</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">Writer</span><span class="o">&amp;</span> <span class="n">writer</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Writer</span><span class="o">&amp;</span> <span class="n">writer</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">set_error</span><span class="p">()</span> <span class="p">{</span> <span class="n">error_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">error</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">error_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="kt">uint64_t</span> <span class="n">capacity_</span> <span class="p">{};</span>      <span class="c1">// ByteStream可以同时容纳的容量</span>
    <span class="kt">bool</span> <span class="n">error_</span> <span class="p">{};</span>        
    <span class="kt">bool</span> <span class="n">closed_</span> <span class="p">{};</span>            <span class="c1">// 字节流是否已经发送到末尾</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">buffer_</span> <span class="p">{};</span>     <span class="c1">// 底层实现可以有多种: string, deque, cycled_queue等等</span>
    <span class="kt">uint64_t</span> <span class="n">pushed_size_</span> <span class="p">{};</span>   <span class="c1">// 从对端发送并压入ByteStream的字节数</span>
    <span class="kt">uint64_t</span> <span class="n">popped_size_</span> <span class="p">{};</span>   <span class="c1">// 发送给客户端并弹出的ByteStream的字节数</span>
<span class="p">}</span>

<span class="c1">// Helper Class 用于从字节流中读取相关的操作</span>
<span class="k">class</span> <span class="nc">Reader</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ByteStream</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">peek</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">pop</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">len</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="n">is_finished</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// Reader 判断是否结束：closed_ 且 bytes_buffered() == 0</span>
    <span class="kt">uint64_t</span> <span class="n">bytes_buffered</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">bytes_popped</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> 
<span class="p">}</span>
<span class="c1">// Helper Class 用于向字节流中写入字节相关操作</span>
<span class="k">class</span> <span class="nc">Writer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ByteStream</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">close</span><span class="p">();</span>

    <span class="kt">bool</span> <span class="n">is_closed</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// Writer 仅需要判断是否 closed_ 为 true 即可</span>
    <span class="kt">uint64_t</span> <span class="n">bytes_pushed</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">available_capacity</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Helper Class 实现</span>
<span class="n">ByteStream</span><span class="o">::</span><span class="n">ByteStream</span><span class="p">(</span> <span class="kt">uint64_t</span> <span class="n">capacity</span> <span class="p">)</span> <span class="o">:</span> <span class="n">capacity_</span><span class="p">(</span> <span class="n">capacity</span> <span class="p">)</span> <span class="p">{}</span>

<span class="kt">bool</span> <span class="n">Writer</span><span class="o">::</span><span class="n">is_closed</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">closed_</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Writer</span><span class="o">::</span><span class="n">push</span><span class="p">(</span> <span class="n">string</span> <span class="n">data</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">error_</span> <span class="o">||</span> <span class="n">is_closed</span><span class="p">()</span> <span class="o">||</span> <span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">available_capacity</span><span class="p">())</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">available_capacity</span><span class="p">());</span>
  <span class="n">buffer_</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
  <span class="n">pushed_size_</span> <span class="o">+=</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Writer</span><span class="o">::</span><span class="n">close</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">closed_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="n">Writer</span><span class="o">::</span><span class="n">available_capacity</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">capacity_</span> <span class="o">-</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="n">Writer</span><span class="o">::</span><span class="n">bytes_pushed</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">pushed_size_</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Reader</span><span class="o">::</span><span class="n">is_finished</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">closed_</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="n">Reader</span><span class="o">::</span><span class="n">bytes_popped</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">popped_size_</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">string_view</span> <span class="n">Reader</span><span class="o">::</span><span class="n">peek</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">buffer_</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Reader</span><span class="o">::</span><span class="n">pop</span><span class="p">(</span> <span class="kt">uint64_t</span> <span class="n">len</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">buffer_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">len</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">buffer_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
  <span class="n">popped_size_</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="n">Reader</span><span class="o">::</span><span class="n">bytes_buffered</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>

</pre></table></code></div></div><p>可以看到这里我们实现 ByteStream 使用的是 <code class="language-plaintext highlighter-rouge">std::string</code>, 而没有使用 <code class="language-plaintext highlighter-rouge">deque</code> 或者 <code class="language-plaintext highlighter-rouge">cycled_queue</code> 原因在于：</p><ol><li><strong>双端队列</strong>，优势在两边插入和弹出的复杂度都为 O(1), 但是 peek 时需要将底层的地址暴露给 string_view, 而双端队列并不是连续的存储，可能 peek 的内容中在双端队列的多个子 buffer 中，不能 O(1) 时间和空间复杂度下提供对应的 view ，需要额外使用其他的连续存储结构来存中间变量，才可保证访问 string_view 的过程中不会出现空悬引用，ByteStream的 peek 的时间复杂度就退化为 O(n) 空间复杂度也为 O(n)；<li><strong>循环队列</strong>，同样的问题，需要处理不连续的情况，如果当前队列存储的内容是连续的状态，那么可以直接提供给 string_view 对应的地址和大小，但出现不连续的情况(一部分在队列尾端，一部分在队列头端)同样会使得循环队列 peek 的时间复杂度提高到 O(n), 同时需要额外的存储，空间复杂度为 O(n);<li><strong>string</strong>, 虽然 string 在 pop 的过程中使用到 substr 使时间复杂度变为 O(n), 但是在 peek 的过程中不会出现不连续存储的情况，保证提供 string_view 的时间复杂度和空间复杂度都为 O(1).</ol><p>那么如果 peek 调用次数较大，使用 <strong>string</strong> 的实现较为合适，插入弹出更为频繁，那么采用<strong>双端队列</strong>或<strong>循环队列</strong>的实现则更合适，我们这里采用 <strong>string</strong> 实现</p><p>字节流应同时提供读写功能，且在两端中都出现，也即一端分别有发送字节流和接收字节流，实现对应的双工字节流管道。</p><h3 id="流重组器reassembler"><span class="me-2">流重组器(Reassembler)</span><a href="#流重组器reassembler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>流重组器，该组件为 Receiver 中保证接收的字节流能够<strong>按序重组</strong>，按照可靠性的要求，保证：</p><p>The TCP must recover from data that is damaged, lost, <strong>duplicated</strong>, or <strong>delivered out of order</strong> by the internet communication system.</p><p><a href="/assets/img/网络TCP总结/reassembler_stream_index.png" class="popup img-link shimmer"><img src="/assets/img/网络TCP总结/reassembler_stream_index.png" alt="" loading="lazy"></a></p><p>中重复的部分会被合理丢弃，乱序字节可以正确重组为原始顺序。为了达到识别正确的顺序已经抛出重复字节，流中的每个字节需要有对应的流下标(<strong>stream_index</strong>)</p><p>流重组器(<strong>StreamReassembler</strong>)定义：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Reassembler</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">Reassembler</span><span class="p">(</span><span class="n">ByteStream</span> <span class="o">&amp;&amp;</span><span class="n">output</span><span class="p">)</span> <span class="o">:</span> <span class="n">output_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">output</span><span class="p">))</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span> <span class="kt">uint64_t</span> <span class="n">first_index</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_last_substring</span> <span class="p">);</span>

    <span class="c1">// 流重组器中等待插入到ByteStream的字节数</span>
    <span class="kt">uint64_t</span> <span class="n">bytes_pending</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// Helper Class interfaces</span>
    <span class="c1">// Access output stream reader</span>
    <span class="n">Reader</span><span class="o">&amp;</span> <span class="n">reader</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">output_</span><span class="p">.</span><span class="n">reader</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">Reader</span><span class="o">&amp;</span> <span class="n">reader</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">output_</span><span class="p">.</span><span class="n">reader</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// Access output stream writer, but const-only (can't write from outside)</span>
    <span class="k">const</span> <span class="n">Writer</span><span class="o">&amp;</span> <span class="n">writer</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">output_</span><span class="p">.</span><span class="n">writer</span><span class="p">();</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">ser_error</span><span class="p">()</span> <span class="p">{</span> <span class="n">output_</span><span class="p">.</span><span class="n">set_error</span><span class="p">();</span> <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">has_error</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">writer</span><span class="p">().</span><span class="n">has_error</span><span class="p">();</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="c1">// Helper Function interact with storage_</span>
    <span class="c1">// insert unvalid data into storage_</span>
    <span class="kt">void</span> <span class="nf">insert_into_storage</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">first_index</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;&amp;</span><span class="n">data</span><span class="p">);</span>
    <span class="c1">// pop all valid data into output_</span>
    <span class="kt">void</span> <span class="nf">pop_from_storage</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">uint64_t</span> <span class="n">bytes_pending_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">storage_</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kt">bool</span> <span class="n">has_last_</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>
    <span class="kt">uint64_t</span> <span class="n">last_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ByteStream</span> <span class="n">output_</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>具体实现：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
</pre><td class="rouge-code"><pre><span class="c1">// 合法性检查：ByteStream 是否有空间存储，data 是否有数据可存</span>
<span class="c1">// 对合法的 data 中不在范围内(ByteStream可以压入的 [index, index+capacity) )</span>
<span class="c1">// 将合法的部分放到自己的 storage 中</span>
<span class="c1">// 如果当前存在storage中的 data 满足压入 ByteStream 的情况，则立刻将 data 压入 ByteStream</span>
<span class="kt">void</span> <span class="n">Reassembler</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span> <span class="kt">uint64_t</span> <span class="n">first_index</span><span class="p">,</span> <span class="n">string</span> <span class="n">data</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_last_substring</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">writer</span><span class="p">().</span><span class="n">available_capacity</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">is_last_substring</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">output_</span><span class="p">.</span><span class="n">writer</span><span class="p">().</span><span class="n">close</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span> <span class="n">is_last_substring</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">has_last_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">last_index</span> <span class="o">=</span> <span class="n">first_index</span> <span class="o">+</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// data's indices: [first_index, end_index)</span>
  <span class="c1">// Bytestream's need to pushed indices: [0, bytes_pushed)</span>
  <span class="c1">//    which means first unpushed index is `bytes_pushed`</span>
  <span class="c1">//    first unacceptable index is bytes_pushed + available_capacity</span>
  <span class="kt">uint64_t</span> <span class="n">end_index</span> <span class="o">=</span> <span class="n">first_index</span> <span class="o">+</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="kt">uint64_t</span> <span class="n">availible_first_index</span> <span class="o">=</span> <span class="n">writer</span><span class="p">().</span><span class="n">bytes_pushed</span><span class="p">();</span>
  <span class="kt">uint64_t</span> <span class="n">unavailible_first_index</span> <span class="o">=</span> <span class="n">writer</span><span class="p">().</span><span class="n">bytes_pushed</span><span class="p">()</span> <span class="o">+</span> <span class="n">writer</span><span class="p">().</span><span class="n">available_capacity</span><span class="p">();</span>

  <span class="c1">// discard all data which totally beyond situations reassebler could handled.</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">end_index</span> <span class="o">&lt;=</span> <span class="n">availible_first_index</span> <span class="o">||</span> <span class="n">first_index</span> <span class="o">&gt;=</span> <span class="n">unavailible_first_index</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// discard last bytes of unavailible data</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">end_index</span> <span class="o">&gt;</span> <span class="n">unavailible_first_index</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">end_index</span> <span class="o">+</span> <span class="n">unavailible_first_index</span> <span class="p">);</span>
    <span class="n">end_index</span> <span class="o">=</span> <span class="n">unavailible_first_index</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// discard prev bytes of data which already pushed</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">first_index</span> <span class="o">&lt;</span> <span class="n">availible_first_index</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="n">availible_first_index</span> <span class="o">-</span> <span class="n">first_index</span> <span class="p">);</span>
    <span class="n">first_index</span> <span class="o">=</span> <span class="n">availible_first_index</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">insert_into_storage</span><span class="p">(</span> <span class="n">first_index</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">data</span> <span class="p">)</span> <span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">availible_first_index</span> <span class="o">==</span> <span class="n">storage_</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">first</span><span class="p">){</span>
    <span class="n">pop_from_storage</span><span class="p">();</span>
    <span class="n">availible_first_index</span> <span class="o">=</span> <span class="n">writer</span><span class="p">().</span><span class="n">bytes_pushed</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="c1">// check if all data pushed into bytestream</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">storage_</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">has_last_</span> <span class="o">&amp;&amp;</span> <span class="n">availible_first_index</span> <span class="o">==</span> <span class="n">last_index</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">output_</span><span class="p">.</span><span class="n">writer</span><span class="p">().</span><span class="n">close</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 将当前压入的data和storage中的data进行比较，实现去重</span>
<span class="c1">// 有重复的部分就剔除，无重复部分按照插入排序的思路将data插入到 storage_ 中</span>
<span class="kt">void</span> <span class="n">Reassembler</span><span class="o">::</span><span class="n">insert_into_storage</span><span class="p">(</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">first_index</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">data</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">begin_index</span> <span class="o">=</span> <span class="n">first_index</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">end_index</span> <span class="o">=</span> <span class="n">begin_index</span> <span class="o">+</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="c1">// find position to insert data in order</span>
  <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">storage_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">storage_</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">begin_index</span> <span class="o">&lt;</span> <span class="n">end_index</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">begin_index</span> <span class="o">&gt;=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">begin_index</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span> <span class="n">begin_index</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">+</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
      <span class="n">it</span><span class="o">++</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">begin_index</span> <span class="o">==</span> <span class="n">first_index</span> <span class="o">&amp;&amp;</span> <span class="n">end_index</span> <span class="o">&lt;=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">bytes_pending_</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">end_index</span> <span class="o">-</span> <span class="n">begin_index</span> <span class="p">);</span>
      <span class="n">storage_</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span> <span class="n">it</span><span class="p">,</span> <span class="n">begin_index</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">data</span> <span class="p">)</span> <span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// begin_index &lt; it-&gt;first</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">right_index</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span> <span class="n">end_index</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="p">);</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">len</span> <span class="o">=</span> <span class="n">right_index</span> <span class="o">-</span> <span class="n">begin_index</span><span class="p">;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">storage_</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span> <span class="n">it</span><span class="p">,</span> <span class="n">begin_index</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="n">begin_index</span> <span class="o">-</span> <span class="n">first_index</span><span class="p">,</span> <span class="n">len</span> <span class="p">)</span> <span class="p">);</span>
    <span class="n">bytes_pending_</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">begin_index</span> <span class="o">=</span> <span class="n">right_index</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// handle situation when storage is empty</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">begin_index</span> <span class="o">&lt;</span> <span class="n">end_index</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">bytes_pending_</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">end_index</span> <span class="o">-</span> <span class="n">begin_index</span> <span class="p">);</span>
    <span class="n">storage_</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span> <span class="n">begin_index</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span> <span class="n">begin_index</span> <span class="o">-</span> <span class="n">first_index</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Reassembler</span><span class="o">::</span><span class="n">pop_from_storage</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">storage_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">storage_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&gt;</span> <span class="n">writer</span><span class="p">().</span><span class="n">bytes_pushed</span><span class="p">()</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">output_</span><span class="p">.</span><span class="n">writer</span><span class="p">().</span><span class="n">push</span><span class="p">(</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="p">);</span>
    <span class="n">bytes_pending_</span> <span class="o">-=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">storage_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">it</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="n">Reassembler</span><span class="o">::</span><span class="n">bytes_pending</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">bytes_pending_</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="接收器receiver"><span class="me-2">接收器(Receiver)</span><a href="#接收器receiver" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虽然有重组器可以将接收到的字节流有序可靠地重组为原始序列，但当字节流要经过网络进行传播时，就需要额外的状态处理实现判断当前字节流是否合法。</p><p>接收器则提供了三种合法状态以及一种异常状态。</p><p><a href="/assets/img/网络TCP总结/TCP_receiver_fsm.png" class="popup img-link shimmer"><img src="/assets/img/网络TCP总结/TCP_receiver_fsm.png" alt="" loading="lazy"></a></p><p>对应的相比字节流，多两个标识位下标：SYN以及FIN，这两个要额外占用序列号，参考下表： <a href="/assets/img/网络TCP总结/TCP_Seq_correspondent_num.png" class="popup img-link shimmer"><img src="/assets/img/网络TCP总结/TCP_Seq_correspondent_num.png" alt="" loading="lazy"></a></p><p>且从外部发送的序列号(Seq)为32bit大小，实际数据传输在100gb/s的情况下只需要<a href="https://cs144.github.io/assignments/check2.pdf">秒级</a>即会消耗完所有的序列号，所以实际上网络中传递的序列号为相对序列号，发送方和接收方内部的序列号为绝对序列号，然后通过转换得到32bit的序列号。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Wrap32</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">Wrap32</span><span class="p">(</span> <span class="kt">uint32_t</span> <span class="n">raw_value</span> <span class="p">)</span> <span class="o">:</span> <span class="n">raw_value_</span><span class="p">(</span> <span class="n">raw_value</span> <span class="p">)</span> <span class="p">{}</span>

  <span class="k">static</span> <span class="n">Wrap32</span> <span class="nf">wrap</span><span class="p">(</span> <span class="kt">uint64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Wrap32</span> <span class="n">zero_point</span> <span class="p">);</span>

  <span class="kt">uint64_t</span> <span class="n">unwrap</span><span class="p">(</span> <span class="n">Wrap32</span> <span class="n">zero_point</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">checkpoint</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">Wrap32</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span> <span class="kt">uint32_t</span> <span class="n">n</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Wrap32</span> <span class="p">{</span> <span class="n">raw_value_</span> <span class="o">+</span> <span class="n">n</span> <span class="p">};</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="k">const</span> <span class="n">Wrap32</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">raw_value_</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">raw_value_</span><span class="p">;</span> <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="kt">uint32_t</span> <span class="n">raw_value_</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="c1">// uint64_t -&gt; Wrap32 时仅需要将高位裁掉即可，然后根据 isn 转为相对 seq</span>
<span class="n">Wrap32</span> <span class="n">Wrap32</span><span class="o">::</span><span class="n">wrap</span><span class="p">(</span> <span class="kt">uint64_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Wrap32</span> <span class="n">zero_point</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">Wrap32</span> <span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">n</span> <span class="p">)</span> <span class="o">+</span> <span class="n">zero_point</span><span class="p">.</span><span class="n">raw_value_</span> <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// Wrap32 -&gt; uint64_t 根据 isn 和 next_seq或bytes_pushed 作为checkpoint 将相对 seq 转为 abs_seq</span>
<span class="kt">uint64_t</span> <span class="n">Wrap32</span><span class="o">::</span><span class="n">unwrap</span><span class="p">(</span> <span class="n">Wrap32</span> <span class="n">zero_point</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">checkpoint</span> <span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">raw_value_</span> <span class="o">-</span> <span class="n">zero_point</span><span class="p">.</span><span class="n">raw_value_</span> <span class="o">-</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">checkpoint</span> <span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">diff</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1u</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)){</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">checkpoint</span> <span class="o">+</span> <span class="n">diff</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">checkpoint</span> <span class="o">-</span> <span class="p">((</span><span class="mi">1ul</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="n">diff</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="n">checkpoint</span><span class="p">){</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">checkpoint</span> <span class="o">+</span> <span class="n">diff</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>TCPReceiver 中，需要考虑当前消息对应实际的流index在哪里，需要从 <code class="language-plaintext highlighter-rouge">seq_no -&gt; abs_seq_no -&gt; stream_index</code> 其中 <code class="language-plaintext highlighter-rouge">stream_index</code> 从实际的内容开始计算下标，而 <code class="language-plaintext highlighter-rouge">abs_seq_no</code> 则从 <code class="language-plaintext highlighter-rouge">SYN</code> segment 开始就开始统计，同时 FIN 也会占用 <code class="language-plaintext highlighter-rouge">abs_seq_no</code>, 所以当我们请求下一个 <code class="language-plaintext highlighter-rouge">segment</code> 时，需要根据当前是否建立连接， <code class="language-plaintext highlighter-rouge">bytestream</code> 是否已经 <code class="language-plaintext highlighter-rouge">close</code> 来计算从 stream_index -&gt; abs_seq_no 的映射</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">TCPReceiver</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// Construct with given Reassembler</span>
  <span class="k">explicit</span> <span class="n">TCPReceiver</span><span class="p">(</span> <span class="n">Reassembler</span><span class="o">&amp;&amp;</span> <span class="n">reassembler</span> <span class="p">)</span> <span class="o">:</span> <span class="n">reassembler_</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">reassembler</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{}</span>

  <span class="cm">/*
   * The TCPReceiver receives TCPSenderMessages, inserting their payload into the Reassembler
   * at the correct stream index.
   */</span>
  <span class="kt">void</span> <span class="nf">receive</span><span class="p">(</span> <span class="n">TCPSenderMessage</span> <span class="n">message</span> <span class="p">);</span>

  <span class="c1">// The TCPReceiver sends TCPReceiverMessages to the peer's TCPSender.</span>
  <span class="n">TCPReceiverMessage</span> <span class="n">send</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Access the output (only Reader is accessible non-const)</span>
  <span class="k">const</span> <span class="n">Reassembler</span><span class="o">&amp;</span> <span class="n">reassembler</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">reassembler_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">Reader</span><span class="o">&amp;</span> <span class="n">reader</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">reassembler_</span><span class="p">.</span><span class="n">reader</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">Reader</span><span class="o">&amp;</span> <span class="n">reader</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">reassembler_</span><span class="p">.</span><span class="n">reader</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">Writer</span><span class="o">&amp;</span> <span class="n">writer</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">reassembler_</span><span class="p">.</span><span class="n">writer</span><span class="p">();</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">set_error</span><span class="p">()</span> <span class="p">{</span> <span class="n">reassembler_</span><span class="p">.</span><span class="n">ser_error</span><span class="p">();</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">has_error</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">reassembler_</span><span class="p">.</span><span class="n">has_error</span><span class="p">();</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Wrap32</span><span class="o">&gt;</span> <span class="n">isn_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
  <span class="n">u_int64_t</span> <span class="n">ackno_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Reassembler</span> <span class="n">reassembler_</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">TCPReceiver</span><span class="o">::</span><span class="n">receive</span><span class="p">(</span> <span class="n">TCPSenderMessage</span> <span class="n">message</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// check if RST segment incoming</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">message</span><span class="p">.</span><span class="n">RST</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">set_error</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span> <span class="n">has_error</span><span class="p">()</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// discard anything before the SYN segment</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">isn_</span><span class="p">.</span><span class="n">has_value</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">message</span><span class="p">.</span><span class="n">SYN</span> <span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="n">isn_</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="n">seqno</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 1. calc abs_seqno from message, seqno -&gt; abs_seqno</span>
  <span class="k">auto</span> <span class="n">abs_seqno</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="n">seqno</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span> <span class="n">isn_</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span> <span class="n">writer</span><span class="p">().</span><span class="n">bytes_pushed</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="c1">// 2. calc stream index from abs_seqno</span>
  <span class="k">auto</span> <span class="n">first_index</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="n">SYN</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">abs_seqno</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

  <span class="n">reassembler_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">first_index</span><span class="p">,</span> <span class="n">message</span><span class="p">.</span><span class="n">payload</span><span class="p">,</span> <span class="n">message</span><span class="p">.</span><span class="n">FIN</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">TCPReceiverMessage</span> <span class="n">TCPReceiver</span><span class="o">::</span><span class="n">send</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="n">TCPReceiverMessage</span> <span class="n">msg</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span> <span class="n">has_error</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">RST</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">auto</span> <span class="n">window_size</span> <span class="o">=</span> <span class="n">writer</span><span class="p">().</span><span class="n">available_capacity</span><span class="p">();</span>
  <span class="n">msg</span><span class="p">.</span><span class="n">window_size</span> <span class="o">=</span> <span class="n">window_size</span> <span class="o">&gt;</span> <span class="n">UINT16_MAX</span> <span class="o">?</span> <span class="n">UINT16_MAX</span> <span class="o">:</span> <span class="n">window_size</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">isn_</span><span class="p">.</span><span class="n">has_value</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">abs_seqno</span> <span class="o">=</span> <span class="n">writer</span><span class="p">().</span><span class="n">bytes_pushed</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">writer</span><span class="p">().</span><span class="n">is_closed</span><span class="p">();</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">ackno</span> <span class="o">=</span> <span class="n">Wrap32</span><span class="o">::</span><span class="n">wrap</span><span class="p">(</span> <span class="n">abs_seqno</span><span class="p">,</span> <span class="n">isn_</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">ackno</span> <span class="o">=</span> <span class="n">nullopt</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">msg</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="发送器sender"><span class="me-2">发送器(Sender)</span><a href="#发送器sender" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>发送器与接收器一样都按照 fsm 设计，根据当前发送的 seq 以及ack 情况判断发送器的 fsm 是什么 <a href="/assets/img/网络TCP总结/TCP_sender_fsm.png" class="popup img-link shimmer"><img src="/assets/img/网络TCP总结/TCP_sender_fsm.png" alt="" loading="lazy"></a></p><p>同时sender要肩负起维持数据传递的任务，所以当发送的 segment 长时间没有 ack(也就是出现超时情况，就要主动发送这些 segments, 在实际实现中存储在 <code class="language-plaintext highlighter-rouge">outstanding_segments_</code> 中)</p><p>使用定时器(Timer)判断当前是否超时，时间更新是通过外部提供(<code class="language-plaintext highlighter-rouge">tick</code> 方法接收), 从而进行判断。同时Timer对象应仅在需要时启动，不需要时关闭(<code class="language-plaintext highlighter-rouge">outstanding_segments_</code>不为空的时候就需要Timer计时).</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">TCPSender</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="cm">/* Construct TCP sender with given default Retransmission Timeout and possible ISN */</span>
  <span class="n">TCPSender</span><span class="p">(</span> <span class="n">ByteStream</span><span class="o">&amp;&amp;</span> <span class="n">input</span><span class="p">,</span> <span class="n">Wrap32</span> <span class="n">isn</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">initial_RTO_ms</span> <span class="p">)</span>
    <span class="o">:</span> <span class="n">input_</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">input</span> <span class="p">)</span> <span class="p">),</span> <span class="n">isn_</span><span class="p">(</span> <span class="n">isn</span> <span class="p">),</span> <span class="n">initial_RTO_ms_</span><span class="p">(</span> <span class="n">initial_RTO_ms</span> <span class="p">),</span> <span class="n">timer_</span><span class="p">(</span><span class="n">initial_RTO_ms</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="cm">/* Generate an empty TCPSenderMessage */</span>
  <span class="n">TCPSenderMessage</span> <span class="n">make_empty_message</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/* Receive and process a TCPReceiverMessage from the peer's receiver */</span>
  <span class="kt">void</span> <span class="nf">receive</span><span class="p">(</span> <span class="k">const</span> <span class="n">TCPReceiverMessage</span><span class="o">&amp;</span> <span class="n">msg</span> <span class="p">);</span>

  <span class="cm">/* Type of the `transmit` function that the push and tick methods can use to send messages */</span>
  <span class="k">using</span> <span class="n">TransmitFunction</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span> <span class="k">const</span> <span class="n">TCPSenderMessage</span><span class="o">&amp;</span> <span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="cm">/* Push bytes from the outbound stream */</span>
  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span> <span class="k">const</span> <span class="n">TransmitFunction</span><span class="o">&amp;</span> <span class="n">transmit</span> <span class="p">);</span>

  <span class="cm">/* Time has passed by the given # of milliseconds since the last time the tick() method was called */</span>
  <span class="kt">void</span> <span class="nf">tick</span><span class="p">(</span> <span class="kt">uint64_t</span> <span class="n">ms_since_last_tick</span><span class="p">,</span> <span class="k">const</span> <span class="n">TransmitFunction</span><span class="o">&amp;</span> <span class="n">transmit</span> <span class="p">);</span>

  <span class="c1">// Accessors</span>
  <span class="kt">uint64_t</span> <span class="n">sequence_numbers_in_flight</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// How many sequence numbers are outstanding?</span>
  <span class="kt">uint64_t</span> <span class="n">consecutive_retransmissions</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// How many consecutive *re*transmissions have happened?</span>
  <span class="n">Writer</span><span class="o">&amp;</span> <span class="n">writer</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">input_</span><span class="p">.</span><span class="n">writer</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">Writer</span><span class="o">&amp;</span> <span class="n">writer</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">input_</span><span class="p">.</span><span class="n">writer</span><span class="p">();</span> <span class="p">}</span>

  <span class="c1">// Access input stream reader, but const-only (can't read from outside)</span>
  <span class="k">const</span> <span class="n">Reader</span><span class="o">&amp;</span> <span class="n">reader</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">input_</span><span class="p">.</span><span class="n">reader</span><span class="p">();</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">set_error</span><span class="p">()</span> <span class="p">{</span> <span class="n">input_</span><span class="p">.</span><span class="n">set_error</span><span class="p">();</span> <span class="p">};</span>

  <span class="kt">bool</span> <span class="nf">has_error</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">input_</span><span class="p">.</span><span class="n">has_error</span><span class="p">();</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// Variables initialized in constructor</span>
  <span class="n">ByteStream</span> <span class="n">input_</span><span class="p">;</span>
  <span class="n">Wrap32</span> <span class="n">isn_</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">initial_RTO_ms_</span><span class="p">;</span>
  <span class="n">Timer</span> <span class="n">timer_</span><span class="p">;</span>

  <span class="kt">uint64_t</span> <span class="n">next_seq_no_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">window_size_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="kt">uint64_t</span> <span class="n">retransmission_cnt_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">seq_no_in_flight_cnt_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="n">syn_</span> <span class="p">{};</span>
  <span class="kt">bool</span> <span class="n">fin_</span> <span class="p">{};</span>

  <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TCPSenderMessage</span><span class="o">&gt;</span> <span class="n">outstanding_segments_</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">};</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
</pre><td class="rouge-code"><pre><span class="kt">uint64_t</span> <span class="n">TCPSender</span><span class="o">::</span><span class="n">sequence_numbers_in_flight</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">seq_no_in_flight_cnt_</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="n">TCPSender</span><span class="o">::</span><span class="n">consecutive_retransmissions</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  
  <span class="k">return</span> <span class="n">retransmission_cnt_</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 约定正常发送的 segment 一定是非空的(即一定是 SYN, FIN 或有 payload 的情况)</span>
<span class="c1">// 发送的 segment 大小受接收窗口，可发送的数据大小以及 MAX_PAYLOAD_SIZE 的影响</span>
<span class="c1">// 非正常情况下(RST, 此时则需要直接发送)</span>
<span class="kt">void</span> <span class="n">TCPSender</span><span class="o">::</span><span class="n">push</span><span class="p">(</span> <span class="k">const</span> <span class="n">TransmitFunction</span><span class="o">&amp;</span> <span class="n">transmit</span> <span class="p">)</span>
<span class="p">{</span>
  
  <span class="k">auto</span> <span class="k">const</span> <span class="n">cur_window_size</span> <span class="o">=</span> <span class="n">window_size_</span> <span class="o">?</span> <span class="n">window_size_</span> <span class="o">:</span> <span class="mi">1u</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="n">cur_window_size</span> <span class="o">&gt;=</span> <span class="n">sequence_numbers_in_flight</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">available_window</span> <span class="o">=</span> <span class="n">cur_window_size</span> <span class="o">-</span> <span class="n">sequence_numbers_in_flight</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">make_empty_message</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">RST</span><span class="p">){</span>
      <span class="n">transmit</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">syn_</span> <span class="p">)</span>
      <span class="n">syn_</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">SYN</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">auto</span> <span class="k">const</span> <span class="n">payload_size</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">min</span><span class="p">(</span>
      <span class="n">TCPConfig</span><span class="o">::</span><span class="n">MAX_PAYLOAD_SIZE</span><span class="p">,</span> 
      <span class="n">available_window</span> <span class="o">-</span> <span class="n">msg</span><span class="p">.</span><span class="n">sequence_length</span><span class="p">()),</span>
      <span class="n">reader</span><span class="p">().</span><span class="n">bytes_buffered</span><span class="p">());</span>
    <span class="n">read</span><span class="p">(</span> <span class="n">input_</span><span class="p">.</span><span class="n">reader</span><span class="p">(),</span> <span class="n">payload_size</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">payload</span> <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">fin_</span> <span class="o">&amp;&amp;</span> <span class="n">reader</span><span class="p">().</span><span class="n">is_finished</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">available_window</span> <span class="o">&gt;</span> <span class="n">msg</span><span class="p">.</span><span class="n">sequence_length</span><span class="p">()</span> <span class="p">)</span>
      <span class="n">fin_</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">FIN</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="c1">// when sequence_length == 0, which is meaningless message</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sequence_length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

    <span class="c1">// special case: FIN message cannot exceed receiver's window</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">msg</span><span class="p">.</span><span class="n">FIN</span> <span class="o">&amp;&amp;</span> <span class="n">available_window</span> <span class="o">&lt;</span> <span class="n">msg</span><span class="p">.</span><span class="n">sequence_length</span><span class="p">()</span> <span class="p">)</span>
      <span class="n">fin_</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">FIN</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    
    <span class="k">const</span> <span class="k">auto</span> <span class="n">size</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">sequence_length</span><span class="p">();</span>

    <span class="n">seq_no_in_flight_cnt_</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">next_seq_no_</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">outstanding_segments_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span> <span class="n">msg</span> <span class="p">);</span>
    <span class="n">transmit</span><span class="p">(</span> <span class="n">msg</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">timer_</span><span class="p">.</span><span class="n">is_running</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">timer_</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">outstanding_segments_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="n">timer_</span><span class="p">.</span><span class="n">stop</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">TCPSenderMessage</span> <span class="n">TCPSender</span><span class="o">::</span><span class="n">make_empty_message</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  
  <span class="k">return</span> <span class="p">{</span> <span class="n">Wrap32</span><span class="o">::</span><span class="n">wrap</span><span class="p">(</span> <span class="n">next_seq_no_</span><span class="p">,</span> <span class="n">isn_</span> <span class="p">),</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="n">has_error</span><span class="p">()};</span>
<span class="p">}</span>

<span class="c1">// TCP receive 的都应是对端发送的 ACK seg</span>
<span class="kt">void</span> <span class="n">TCPSender</span><span class="o">::</span><span class="n">receive</span><span class="p">(</span> <span class="k">const</span> <span class="n">TCPReceiverMessage</span><span class="o">&amp;</span> <span class="n">msg</span> <span class="p">)</span>
<span class="p">{</span>
  
  <span class="n">window_size_</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">window_size</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span> <span class="n">msg</span><span class="p">.</span><span class="n">RST</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">set_error</span><span class="p">();</span>
    <span class="n">timer_</span><span class="p">.</span><span class="n">stop</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="c1">// error state, don't do any thing!</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">has_error</span><span class="p">()</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="c1">// no any ackno is meaningless for sender</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">msg</span><span class="p">.</span><span class="n">ackno</span><span class="p">.</span><span class="n">has_value</span><span class="p">()</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="k">auto</span> <span class="k">const</span> <span class="n">received_abs_ack_no</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">ackno</span><span class="o">-&gt;</span><span class="n">unwrap</span><span class="p">(</span> <span class="n">isn_</span><span class="p">,</span> <span class="n">next_seq_no_</span> <span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">received_abs_ack_no</span> <span class="o">&gt;</span> <span class="n">next_seq_no_</span> <span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Now we got the newest msg to update current state</span>
  <span class="c1">// check if any outstanding segments already received.</span>
  <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="n">outstanding_segments_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">front_seg</span> <span class="o">=</span> <span class="n">outstanding_segments_</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="c1">// front seg still not sent to peer successfully</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">front_seg</span><span class="p">.</span><span class="n">seqno</span><span class="p">.</span><span class="n">unwrap</span><span class="p">(</span> <span class="n">isn_</span><span class="p">,</span> <span class="n">next_seq_no_</span> <span class="p">)</span> <span class="o">+</span> <span class="n">front_seg</span><span class="p">.</span><span class="n">sequence_length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">received_abs_ack_no</span> <span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">seq_no_in_flight_cnt_</span> <span class="o">-=</span> <span class="n">front_seg</span><span class="p">.</span><span class="n">sequence_length</span><span class="p">();</span>
    <span class="n">outstanding_segments_</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="n">success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span> <span class="n">success</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">timer_</span><span class="p">.</span><span class="n">reset_RTO</span><span class="p">();</span>
    <span class="n">retransmission_cnt_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">timer_</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span> <span class="n">outstanding_segments_</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span>
    <span class="n">timer_</span><span class="p">.</span><span class="n">stop</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 根据timer判断发送的segment 是否超时，并进行重传操作和统计重传次数</span>
<span class="kt">void</span> <span class="n">TCPSender</span><span class="o">::</span><span class="n">tick</span><span class="p">(</span> <span class="kt">uint64_t</span> <span class="n">ms_since_last_tick</span><span class="p">,</span> <span class="k">const</span> <span class="n">TransmitFunction</span><span class="o">&amp;</span> <span class="n">transmit</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">timer_</span><span class="p">.</span><span class="n">tick</span><span class="p">(</span> <span class="n">ms_since_last_tick</span> <span class="p">);</span>
  <span class="c1">// send the oldest outstanding segment when timer is expired</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">timer_</span><span class="p">.</span><span class="n">is_expired</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">transmit</span><span class="p">(</span> <span class="n">outstanding_segments_</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">window_size_</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">retransmission_cnt_</span><span class="p">;</span>
      <span class="n">timer_</span><span class="p">.</span><span class="n">double_RTO</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">timer_</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="连接器connection"><span class="me-2">连接器(Connection)</span><a href="#连接器connection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>连接器中同时有 sender 和 receiver 两个实体，而Connection 自身不需要实现这两个实体的功能，而是更多关注在连接相关的事务：</p><ol><li>主动与对端建立连接，关闭连接，同时支持被动关闭连接.<li>实现 CLOSED_WAIT 状态，这里我们实现的超时时长为 10 * rt_time, 也就是关闭连接的一段时间还需要再等等，对端可能还有最后的数据没发(继续向对端发送ack seg).<li>实现捎带机制：每次需要发送 ack seg 前，我们都尝试将 acked 部分放入sender将要发送的seg 中(sender的seg ack部分必然为空), 减少额外的发送 seg 量，将发送的 seg 变为 SEQ+ACK seg. 当然 sender 没有要发送的 seg 我们就只能手动创建一个 ACK seg.<li>主动处理异常状态：本端 bytestream 设置为 error 状态或者对端发送的 seg 中带有 RST 时，可以计时将自身状态转变为 error 状态, 在之后本端要发送的 seg 都会被拦截并改发送为 RST seg, 同时也不再处理对端发送的 seg.</ol><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
</pre><td class="rouge-code"><pre><span class="c1">//! \brief A complete endpoint of a TCP connection</span>
<span class="k">class</span> <span class="nc">TCPConnection</span> <span class="p">{</span>
  <span class="nl">private:</span>
    <span class="n">TCPConfig</span> <span class="n">_cfg</span><span class="p">;</span>
    <span class="n">TCPReceiver</span> <span class="n">_receiver</span><span class="p">{</span><span class="n">_cfg</span><span class="p">.</span><span class="n">recv_capacity</span><span class="p">};</span>
    <span class="n">TCPSender</span> <span class="n">_sender</span><span class="p">{</span><span class="n">_cfg</span><span class="p">.</span><span class="n">send_capacity</span><span class="p">,</span> <span class="n">_cfg</span><span class="p">.</span><span class="n">rt_timeout</span><span class="p">,</span> <span class="n">_cfg</span><span class="p">.</span><span class="n">fixed_isn</span><span class="p">};</span>

    <span class="c1">//! outbound queue of segments that the TCPConnection wants sent</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TCPSegment</span><span class="o">&gt;</span> <span class="n">_segments_out</span><span class="p">{};</span>

    <span class="c1">//! Should the TCPConnection stay active (and keep ACKing)</span>
    <span class="c1">//! for 10 * _cfg.rt_timeout milliseconds after both streams have ended,</span>
    <span class="c1">//! in case the remote TCPConnection doesn't know we've received its whole stream?</span>
    <span class="kt">bool</span> <span class="n">_linger_after_streams_finish</span><span class="p">{</span><span class="nb">true</span><span class="p">};</span>

    <span class="kt">size_t</span> <span class="n">_time_since_last_segment_received</span><span class="p">{};</span>

    <span class="kt">bool</span> <span class="n">_active</span><span class="p">{</span><span class="nb">true</span><span class="p">};</span>

  <span class="k">private</span><span class="o">:</span>
    <span class="c1">//! \brief Every time send outbound seg, try to make up ACK part if possible</span>
    <span class="kt">void</span> <span class="nf">_send_with_ack_if_possible</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">_set_rst_state</span><span class="p">();</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="c1">//! \name "Input" interface for the writer</span>
    <span class="c1">//!@{</span>

    <span class="c1">//! \brief Initiate a connection by sending a SYN segment</span>
    <span class="kt">void</span> <span class="nf">connect</span><span class="p">();</span>

    <span class="c1">//! \brief Write data to the outbound byte stream, and send it over TCP if possible</span>
    <span class="c1">//! \returns the number of bytes from `data` that were actually written.</span>
    <span class="kt">size_t</span> <span class="nf">write</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>

    <span class="c1">//! \returns the number of `bytes` that can be written right now.</span>
    <span class="kt">size_t</span> <span class="n">remaining_outbound_capacity</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! \brief Shut down the outbound byte stream (still allows reading incoming data)</span>
    <span class="kt">void</span> <span class="nf">end_input_stream</span><span class="p">();</span>
    <span class="c1">//!@}</span>

    <span class="c1">//! \name "Output" interface for the reader</span>
    <span class="c1">//!@{</span>

    <span class="c1">//! \brief The inbound byte stream received from the peer</span>
    <span class="n">ByteStream</span> <span class="o">&amp;</span><span class="n">inbound_stream</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_receiver</span><span class="p">.</span><span class="n">stream_out</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">//!@}</span>

    <span class="c1">//! \name Accessors used for testing</span>

    <span class="c1">//!@{</span>
    <span class="c1">//! \brief number of bytes sent and not yet acknowledged, counting SYN/FIN each as one byte</span>
    <span class="kt">size_t</span> <span class="n">bytes_in_flight</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! \brief number of bytes not yet reassembled</span>
    <span class="kt">size_t</span> <span class="n">unassembled_bytes</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! \brief Number of milliseconds since the last segment was received</span>
    <span class="kt">size_t</span> <span class="n">time_since_last_segment_received</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//!&lt; \brief summarize the state of the sender, receiver, and the connection</span>
    <span class="n">TCPState</span> <span class="n">state</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span><span class="n">_sender</span><span class="p">,</span> <span class="n">_receiver</span><span class="p">,</span> <span class="n">active</span><span class="p">(),</span> <span class="n">_linger_after_streams_finish</span><span class="p">};</span> <span class="p">};</span>
    <span class="c1">//!@}</span>

    <span class="c1">//! \name Methods for the owner or operating system to call</span>
    <span class="c1">//!@{</span>

    <span class="c1">//! Called when a new segment has been received from the network</span>
    <span class="kt">void</span> <span class="nf">segment_received</span><span class="p">(</span><span class="k">const</span> <span class="n">TCPSegment</span> <span class="o">&amp;</span><span class="n">seg</span><span class="p">);</span>

    <span class="c1">//! Called periodically when time elapses</span>
    <span class="kt">void</span> <span class="nf">tick</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">ms_since_last_tick</span><span class="p">);</span>

    <span class="c1">//! \brief TCPSegments that the TCPConnection has enqueued for transmission.</span>
    <span class="c1">//! \note The owner or operating system will dequeue these and</span>
    <span class="c1">//! put each one into the payload of a lower-layer datagram (usually Internet datagrams (IP),</span>
    <span class="c1">//! but could also be user datagrams (UDP) or any other kind).</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TCPSegment</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">segments_out</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_segments_out</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">//! \brief Is the connection still alive in any way?</span>
    <span class="c1">//! \returns `true` if either stream is still running or if the TCPConnection is lingering</span>
    <span class="c1">//! after both streams have finished (e.g. to ACK retransmissions from the peer)</span>
    <span class="kt">bool</span> <span class="n">active</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//!@}</span>

    <span class="c1">//! Construct a new connection from a configuration</span>
    <span class="k">explicit</span> <span class="n">TCPConnection</span><span class="p">(</span><span class="k">const</span> <span class="n">TCPConfig</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">)</span> <span class="o">:</span> <span class="n">_cfg</span><span class="p">{</span><span class="n">cfg</span><span class="p">}</span> <span class="p">{}</span>

    <span class="c1">//! \name construction and destruction</span>
    <span class="c1">//! moving is allowed; copying is disallowed; default construction not possible</span>

    <span class="c1">//!@{</span>
    <span class="o">~</span><span class="n">TCPConnection</span><span class="p">();</span>  <span class="c1">//!&lt; destructor sends a RST if the connection is still open</span>
    <span class="n">TCPConnection</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">TCPConnection</span><span class="p">(</span><span class="n">TCPConnection</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">TCPConnection</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TCPConnection</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">TCPConnection</span><span class="p">(</span><span class="k">const</span> <span class="n">TCPConnection</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">TCPConnection</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TCPConnection</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="c1">//!@}</span>
<span class="p">};</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
</pre><td class="rouge-code"><pre><span class="kt">size_t</span> <span class="n">TCPConnection</span><span class="o">::</span><span class="n">remaining_outbound_capacity</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_sender</span><span class="p">.</span><span class="n">stream_in</span><span class="p">().</span><span class="n">remaining_capacity</span><span class="p">();</span> <span class="p">}</span>

<span class="kt">size_t</span> <span class="n">TCPConnection</span><span class="o">::</span><span class="n">bytes_in_flight</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_sender</span><span class="p">.</span><span class="n">bytes_in_flight</span><span class="p">();</span> <span class="p">}</span>

<span class="kt">size_t</span> <span class="n">TCPConnection</span><span class="o">::</span><span class="n">unassembled_bytes</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_receiver</span><span class="p">.</span><span class="n">unassembled_bytes</span><span class="p">();</span> <span class="p">}</span>

<span class="kt">size_t</span> <span class="n">TCPConnection</span><span class="o">::</span><span class="n">time_since_last_segment_received</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_time_since_last_segment_received</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">TCPConnection</span><span class="o">::</span><span class="n">segment_received</span><span class="p">(</span><span class="k">const</span> <span class="n">TCPSegment</span> <span class="o">&amp;</span><span class="n">seg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_time_since_last_segment_received</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">header</span> <span class="o">=</span> <span class="n">seg</span><span class="p">.</span><span class="n">header</span><span class="p">();</span>

    <span class="k">if</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">rst</span><span class="p">){</span>
        <span class="n">_set_rst_state</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">need_empty_seg</span> <span class="o">=</span> <span class="n">seg</span><span class="p">.</span><span class="n">length_in_sequence_space</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">_receiver</span><span class="p">.</span><span class="n">segment_received</span><span class="p">(</span><span class="n">seg</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">ack</span><span class="p">){</span>
        <span class="n">_sender</span><span class="p">.</span><span class="n">ack_received</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">ackno</span><span class="p">,</span> <span class="n">header</span><span class="p">.</span><span class="n">win</span><span class="p">);</span>    
        <span class="k">if</span><span class="p">(</span><span class="n">need_empty_seg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">_sender</span><span class="p">.</span><span class="n">segments_out</span><span class="p">().</span><span class="n">empty</span><span class="p">()){</span>
            <span class="n">need_empty_seg</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// _receiver LISTEN -&gt; SYN_RECV state</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">TCPState</span><span class="o">::</span><span class="n">state_summary</span><span class="p">(</span><span class="n">_sender</span><span class="p">)</span> <span class="o">==</span> <span class="n">TCPSenderStateSummary</span><span class="o">::</span><span class="n">CLOSED</span> <span class="o">&amp;&amp;</span>
        <span class="n">TCPState</span><span class="o">::</span><span class="n">state_summary</span><span class="p">(</span><span class="n">_receiver</span><span class="p">)</span> <span class="o">==</span> <span class="n">TCPReceiverStateSummary</span><span class="o">::</span><span class="n">SYN_RECV</span><span class="p">){</span>
        <span class="n">connect</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// _receiver FIN_RECV -&gt; PASSIVE close (CLOSE WAIT)</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">TCPState</span><span class="o">::</span><span class="n">state_summary</span><span class="p">(</span><span class="n">_sender</span><span class="p">)</span> <span class="o">==</span> <span class="n">TCPSenderStateSummary</span><span class="o">::</span><span class="n">SYN_ACKED</span> <span class="o">&amp;&amp;</span>
        <span class="n">TCPState</span><span class="o">::</span><span class="n">state_summary</span><span class="p">(</span><span class="n">_receiver</span><span class="p">)</span> <span class="o">==</span> <span class="n">TCPReceiverStateSummary</span><span class="o">::</span><span class="n">FIN_RECV</span><span class="p">){</span>
        <span class="n">_linger_after_streams_finish</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// PASSIVE close</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">_linger_after_streams_finish</span> <span class="o">&amp;&amp;</span>
        <span class="n">TCPState</span><span class="o">::</span><span class="n">state_summary</span><span class="p">(</span><span class="n">_sender</span><span class="p">)</span> <span class="o">==</span> <span class="n">TCPSenderStateSummary</span><span class="o">::</span><span class="n">FIN_ACKED</span> <span class="o">&amp;&amp;</span>
        <span class="n">TCPState</span><span class="o">::</span><span class="n">state_summary</span><span class="p">(</span><span class="n">_receiver</span><span class="p">)</span> <span class="o">==</span> <span class="n">TCPReceiverStateSummary</span><span class="o">::</span><span class="n">FIN_RECV</span><span class="p">){</span>
        <span class="n">_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// keep-alive</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">_receiver</span><span class="p">.</span><span class="n">ackno</span><span class="p">().</span><span class="n">has_value</span><span class="p">()</span> <span class="o">&amp;&amp;</span> 
        <span class="n">seg</span><span class="p">.</span><span class="n">length_in_sequence_space</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="n">_receiver</span><span class="p">.</span><span class="n">ackno</span><span class="p">().</span><span class="n">value</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">seg</span><span class="p">.</span><span class="n">header</span><span class="p">().</span><span class="n">seqno</span><span class="p">){</span>
        <span class="n">need_empty_seg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">need_empty_seg</span><span class="p">)</span>
        <span class="n">_sender</span><span class="p">.</span><span class="n">send_empty_segment</span><span class="p">();</span>

    <span class="n">_send_with_ack_if_possible</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">TCPConnection</span><span class="o">::</span><span class="n">active</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_active</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">size_t</span> <span class="n">TCPConnection</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">write_size</span> <span class="o">=</span> <span class="n">_sender</span><span class="p">.</span><span class="n">stream_in</span><span class="p">().</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">_sender</span><span class="p">.</span><span class="n">fill_window</span><span class="p">();</span>

    <span class="n">_send_with_ack_if_possible</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">write_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span>
<span class="kt">void</span> <span class="n">TCPConnection</span><span class="o">::</span><span class="n">tick</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">ms_since_last_tick</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_time_since_last_segment_received</span> <span class="o">+=</span> <span class="n">ms_since_last_tick</span><span class="p">;</span>
    <span class="n">_sender</span><span class="p">.</span><span class="n">tick</span><span class="p">(</span><span class="n">ms_since_last_tick</span><span class="p">);</span>

    <span class="c1">// maximum retry time limit</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_sender</span><span class="p">.</span><span class="n">consecutive_retransmissions</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">TCPConfig</span><span class="o">::</span><span class="n">MAX_RETX_ATTEMPTS</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="n">segments_out</span><span class="p">().</span><span class="n">size</span><span class="p">())</span> <span class="n">segments_out</span><span class="p">().</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">_set_rst_state</span><span class="p">();</span>
        <span class="n">TCPSegment</span> <span class="n">seg</span><span class="p">;</span>
        <span class="n">seg</span><span class="p">.</span><span class="n">header</span><span class="p">().</span><span class="n">rst</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">seg</span><span class="p">.</span><span class="n">header</span><span class="p">().</span><span class="n">seqno</span> <span class="o">=</span> <span class="n">_sender</span><span class="p">.</span><span class="n">next_seqno</span><span class="p">();</span>
        <span class="n">segments_out</span><span class="p">().</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">seg</span><span class="p">));</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">_send_with_ack_if_possible</span><span class="p">();</span>

    <span class="c1">// ACTIVE CLOSE</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">_linger_after_streams_finish</span> <span class="o">&amp;&amp;</span>
        <span class="n">TCPState</span><span class="o">::</span><span class="n">state_summary</span><span class="p">(</span><span class="n">_sender</span><span class="p">)</span> <span class="o">==</span> <span class="n">TCPSenderStateSummary</span><span class="o">::</span><span class="n">FIN_ACKED</span> <span class="o">&amp;&amp;</span>
        <span class="n">TCPState</span><span class="o">::</span><span class="n">state_summary</span><span class="p">(</span><span class="n">_receiver</span><span class="p">)</span> <span class="o">==</span> <span class="n">TCPReceiverStateSummary</span><span class="o">::</span><span class="n">FIN_RECV</span> <span class="o">&amp;&amp;</span>
        <span class="n">_time_since_last_segment_received</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">_cfg</span><span class="p">.</span><span class="n">rt_timeout</span><span class="p">){</span>
        <span class="n">_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">_linger_after_streams_finish</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TCPConnection</span><span class="o">::</span><span class="n">end_input_stream</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// _sender convert to FIN_SENT state</span>
    <span class="n">_sender</span><span class="p">.</span><span class="n">stream_in</span><span class="p">().</span><span class="n">end_input</span><span class="p">();</span>
    <span class="n">_sender</span><span class="p">.</span><span class="n">fill_window</span><span class="p">();</span>
    <span class="n">_send_with_ack_if_possible</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TCPConnection</span><span class="o">::</span><span class="n">connect</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TCPState</span><span class="o">::</span><span class="n">state_summary</span><span class="p">(</span><span class="n">_sender</span><span class="p">)</span> <span class="o">==</span> <span class="n">TCPSenderStateSummary</span><span class="o">::</span><span class="n">CLOSED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_sender</span><span class="p">.</span><span class="n">fill_window</span><span class="p">();</span>
        <span class="n">_send_with_ack_if_possible</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TCPConnection</span><span class="o">::</span><span class="n">_send_with_ack_if_possible</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">_sender</span><span class="p">.</span><span class="n">segments_out</span><span class="p">().</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">seg</span> <span class="o">=</span> <span class="n">_sender</span><span class="p">.</span><span class="n">segments_out</span><span class="p">().</span><span class="n">front</span><span class="p">();</span>
        <span class="c1">// If seg's ACK part is blank, we try to add it</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_receiver</span><span class="p">.</span><span class="n">ackno</span><span class="p">().</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">seg</span><span class="p">.</span><span class="n">header</span><span class="p">().</span><span class="n">ack</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">seg</span><span class="p">.</span><span class="n">header</span><span class="p">().</span><span class="n">ackno</span> <span class="o">=</span> <span class="n">_receiver</span><span class="p">.</span><span class="n">ackno</span><span class="p">().</span><span class="n">value</span><span class="p">();</span>
            <span class="n">seg</span><span class="p">.</span><span class="n">header</span><span class="p">().</span><span class="n">win</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">_receiver</span><span class="p">.</span><span class="n">window_size</span><span class="p">(),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">UINT16_MAX</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">segments_out</span><span class="p">().</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">seg</span><span class="p">));</span>
        <span class="n">_sender</span><span class="p">.</span><span class="n">segments_out</span><span class="p">().</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TCPConnection</span><span class="o">::</span><span class="n">_set_rst_state</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_sender</span><span class="p">.</span><span class="n">stream_in</span><span class="p">().</span><span class="n">set_error</span><span class="p">();</span>
    <span class="n">_receiver</span><span class="p">.</span><span class="n">stream_out</span><span class="p">().</span><span class="n">set_error</span><span class="p">();</span>
    <span class="n">_linger_after_streams_finish</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">_active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TCPConnection</span><span class="o">::~</span><span class="n">TCPConnection</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">active</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Warning: Unclean shutdown of TCPConnection</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

            <span class="c1">// Your code here: need to send a RST segment to the peer</span>
            <span class="n">_set_rst_state</span><span class="p">();</span>
            <span class="n">TCPSegment</span> <span class="n">seg</span><span class="p">;</span>
            <span class="n">seg</span><span class="p">.</span><span class="n">header</span><span class="p">().</span><span class="n">rst</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">seg</span><span class="p">.</span><span class="n">header</span><span class="p">().</span><span class="n">seqno</span> <span class="o">=</span> <span class="n">_sender</span><span class="p">.</span><span class="n">next_seqno</span><span class="p">();</span>
            <span class="n">_segments_out</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">seg</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Exception destructing TCP FSM: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/%E5%9F%BA%E7%A1%80/">基础</a>, <a href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/%E5%9F%BA%E7%A1%80/" class="post-tag no-text-decoration" >基础</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E7%BD%91%E7%BB%9CTCP%E6%80%BB%E7%BB%93%20-%20%E5%A2%A8%E5%A2%A8%E9%B1%BC%E7%9A%84%E5%8D%9A%E5%AE%A2&url=https%3A%2F%2Fmracli.github.io%2Fposts%2F%25E7%25BD%2591%25E7%25BB%259CTCP%25E6%2580%25BB%25E7%25BB%2593%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E7%BD%91%E7%BB%9CTCP%E6%80%BB%E7%BB%93%20-%20%E5%A2%A8%E5%A2%A8%E9%B1%BC%E7%9A%84%E5%8D%9A%E5%AE%A2&u=https%3A%2F%2Fmracli.github.io%2Fposts%2F%25E7%25BD%2591%25E7%25BB%259CTCP%25E6%2580%25BB%25E7%25BB%2593%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fmracli.github.io%2Fposts%2F%25E7%25BD%2591%25E7%25BB%259CTCP%25E6%2580%25BB%25E7%25BB%2593%2F&text=%E7%BD%91%E7%BB%9CTCP%E6%80%BB%E7%BB%93%20-%20%E5%A2%A8%E5%A2%A8%E9%B1%BC%E7%9A%84%E5%8D%9A%E5%AE%A2" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="分享链接" data-title-succeed="链接已复制！" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">最近更新</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/CMU445_proj1/">CMU445 Project 1</a><li class="text-truncate lh-lg"> <a href="/posts/%E9%9D%A2%E8%AF%95/">一些常识性内容的积累</a><li class="text-truncate lh-lg"> <a href="/posts/%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95/">DH算法及TLS/1.2/1.3握手</a><li class="text-truncate lh-lg"> <a href="/posts/HyperLogLog/">HyperLogLog</a><li class="text-truncate lh-lg"> <a href="/posts/coroutine/">从异步回调到C++20中的协程</a></ul></section><section><h2 class="panel-heading">热门标签</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag btn btn-outline-primary" href="/tags/linux/">Linux</a> <a class="post-tag btn btn-outline-primary" href="/tags/c/">C++</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a> <a class="post-tag btn btn-outline-primary" href="/tags/cmake/">CMake</a> <a class="post-tag btn btn-outline-primary" href="/tags/stl%E5%AE%B9%E5%99%A8/">stl容器</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E6%95%99%E7%A8%8B/">教程</a> <a class="post-tag btn btn-outline-primary" href="/tags/gtest/">GTest</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">LeetCode</a></div></section></div><section id="toc-wrapper" class="d-none ps-0 pe-4"><h2 class="panel-heading ps-3 mb-2">文章内容</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">相关文章</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1725701460" data-df="YYYY/MM/DD" > 2024/09/07 </time><h4 class="pt-0 my-2">DH算法及TLS/1.2/1.3握手</h4><div class="text-muted"><p>谁知道哪一天就会学到新东西，就像缘分一样...</p></div></div></a></article><article class="col"> <a href="/posts/aaS/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1717596600" data-df="YYYY/MM/DD" > 2024/06/05 </time><h4 class="pt-0 my-2">即服务aSS</h4><div class="text-muted"><p>剪短的描述</p></div></div></a></article><article class="col"> <a href="/posts/CMU445_proj1/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1728905100" data-df="YYYY/MM/DD" > 2024/10/14 </time><h4 class="pt-0 my-2">CMU445 Project 1</h4><div class="text-muted"><p>BufferPool：空间换时间的经典实现</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95/" class="btn btn-outline-primary" aria-label="上一篇" ><p>DH算法及TLS/1.2/1.3握手</p></a> <a href="/posts/HyperLogLog/" class="btn btn-outline-primary" aria-label="下一篇" ><p>HyperLogLog</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2024</time> <a href="https://github.com/mracli">墨墨鱼</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。" >保留部分权利。</span></p><p>本站采用 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 主题 <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.0.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a></p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">热门标签</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag btn btn-outline-primary" href="/tags/linux/">Linux</a> <a class="post-tag btn btn-outline-primary" href="/tags/c/">C++</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a> <a class="post-tag btn btn-outline-primary" href="/tags/cmake/">CMake</a> <a class="post-tag btn btn-outline-primary" href="/tags/stl%E5%AE%B9%E5%99%A8/">stl容器</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E6%95%99%E7%A8%8B/">教程</a> <a class="post-tag btn btn-outline-primary" href="/tags/gtest/">GTest</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">LeetCode</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><aside id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-animation="true" data-bs-autohide="false" ><div class="toast-header"> <button type="button" class="btn-close ms-auto" data-bs-dismiss="toast" aria-label="Close" ></button></div><div class="toast-body text-center pt-0"><p class="px-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></aside><script src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.11/dayjs.min.js,npm/dayjs@1.11.11/locale/zh.min.js,npm/dayjs@1.11.11/plugin/relativeTime.min.js,npm/dayjs@1.11.11/plugin/localizedFormat.min.js,npm/tocbot@4.27.20/dist/tocbot.min.js"></script> <script src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script defer src="/assets/js/dist/app.min.js"></script> <script>SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
